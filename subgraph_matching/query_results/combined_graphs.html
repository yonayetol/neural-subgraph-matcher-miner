<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <title>Target Graph with Subgraph Highlighted</title>
    <style>
        :root {
            /* Color Palette - Light Theme */
            --bg-primary: #fafafa;
            --bg-secondary: rgba(255, 255, 255, 0.9);
            --border-light: rgba(0, 0, 0, 0.1);
            --text-primary: #374151;
            --text-secondary: #6b7280;
            
            /* Node Colors */
            --node-default: rgba(59, 130, 246, 0.7);
            --node-anchor: rgba(239, 68, 68, 0.8);
            --node-border: rgba(0, 0, 0, 0.3);
            
            /* Edge Colors */
            --edge-default: rgba(107, 114, 128, 0.6);
            --edge-hover: rgba(59, 130, 246, 0.8);
            
            /* UI Elements */
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --card-border: rgba(0, 0, 0, 0.1);
            
            /* Grid Colors */
            --grid-minor: rgba(0, 0, 0, 0.03);
            --grid-major: rgba(0, 0, 0, 0.08);
            --grid-axis: rgba(59, 130, 246, 0.15);
            --grid-dots: rgba(0, 0, 0, 0.1);
            --grid-center: rgba(59, 130, 246, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--bg-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* Full-screen canvas container */
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #graph-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
            background-color: var(--bg-primary);
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(0,0,0,0.02) 1px, transparent 0);
            background-size: 20px 20px;
        }

        #graph-canvas:active {
            cursor: grabbing;
        }

        /* Grid background overlay - disabled since we draw grid on canvas */
        #grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none; /* Grid is now drawn on canvas for proper transformation */
        }

        /* Base UI card styling */
        .ui-card {
            position: absolute;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(10px);
            z-index: 1000;
            padding: 12px;
            color: var(--text-primary);
            font-size: 14px;
        }

        /* Floating UI component positions */
        .top-left {
            top: 20px;
            left: 20px;
        }

        .top-center {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .top-right {
            top: 20px;
            right: 20px;
        }

        .bottom-right-upper {
            bottom: 180px;
            right: 20px;
        }

        .bottom-right-lower {
            bottom: 20px;
            right: 20px;
        }

        /* Title bar styling */
        #title-bar {
            text-align: center;
            font-weight: 600;
            font-size: 16px;
            min-width: 300px;
        }

        #title-bar .subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Zoom controls styling */
        #zoom-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        #zoom-controls button {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        #zoom-controls button:hover {
            background: var(--bg-primary);
            border-color: var(--text-secondary);
        }

        #zoom-controls button:active {
            transform: scale(0.95);
        }

        /* Legend card styling */
        #legend-card {
            min-width: 220px;
            max-width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        #legend-card h3 {
            margin-bottom: 16px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-light);
            padding-bottom: 8px;
        }

        .legend-section {
            margin-bottom: 16px;
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-section h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
            font-size: 12px;
            padding: 2px 0;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid var(--border-light);
            flex-shrink: 0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .legend-shape {
            width: 18px;
            height: 18px;
            border: 1px solid var(--border-light);
            flex-shrink: 0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .legend-item span {
            color: var(--text-primary);
            font-weight: 500;
            line-height: 1.2;
        }

        /* Controls card styling */
        #controls-card {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 200px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--node-default);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .export-buttons {
            display: flex;
            gap: 8px;
        }

        .export-buttons button {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid var(--border-light);
            border-radius: 4px;
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .export-buttons button:hover {
            background: var(--bg-primary);
            border-color: var(--text-secondary);
        }

        /* Context menu styling */
        #context-menu {
            position: absolute;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            box-shadow: var(--card-shadow);
            backdrop-filter: blur(10px);
            z-index: 2000;
            padding: 4px 0;
            min-width: 120px;
        }

        #context-menu.hidden {
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-primary);
            transition: background-color 0.2s ease;
        }

        .context-menu-item:hover {
            background-color: var(--bg-primary);
        }

        /* Isolation effects */
        .node-isolated {
            filter: blur(2px);
            opacity: 0.3;
        }

        .edge-isolated {
            filter: blur(2px);
            opacity: 0.2;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .ui-card {
                padding: 8px;
                font-size: 12px;
            }
            
            .top-left, .top-right {
                top: 10px;
            }
            
            .top-left {
                left: 10px;
            }
            
            .top-right {
                right: 10px;
            }
            
            .bottom-right-upper {
                bottom: 140px;
                right: 10px;
            }
            
            .bottom-right-lower {
                bottom: 10px;
                right: 10px;
            }
            
            #title-bar {
                min-width: 200px;
                font-size: 14px;
            }
            
            #zoom-controls button {
                width: 32px;
                height: 32px;
                font-size: 16px;
            }
            
            #legend-card, #controls-card {
                min-width: 160px;
            }
        }

        @media (max-width: 480px) {
            .ui-card {
                padding: 6px;
                font-size: 11px;
            }
            
            #title-bar {
                min-width: 150px;
                font-size: 12px;
            }
            
            #zoom-controls button {
                width: 28px;
                height: 28px;
                font-size: 14px;
            }
            
            #legend-card, #controls-card {
                min-width: 140px;
            }
        }
    </style>
</head>
<body>
    <!-- Full-screen canvas container -->
    <div id="canvas-container">
        <canvas id="graph-canvas"></canvas>
        <div id="grid-overlay"></div>
    </div>
    
    <!-- Floating UI Components -->
    
    <!-- Title bar at center-top -->
    <div id="title-bar" class="ui-card top-center">
        <div id="graph-title">Graph Visualization</div>
        <div class="subtitle" id="graph-stats">Loading...</div>
    </div>
    
    <!-- Zoom controls in top-right corner -->
    <div id="zoom-controls" class="ui-card top-right">
        <button id="zoom-in" title="Zoom In">+</button>
        <button id="zoom-out" title="Zoom Out">−</button>
        <button id="recenter" title="Recenter">⌂</button>
    </div>
    
    <!-- Legend card in bottom-right area (upper) -->
    <div id="legend-card" class="ui-card bottom-right-upper">
        <h3>Legend</h3>
        <div id="legend-content">
            <!-- Legend items will be populated by JavaScript -->
        </div>
    </div>
    
    <!-- Controls card in bottom-right area (lower) -->
    <div id="controls-card" class="ui-card bottom-right-lower">
        <div class="control-group">
            <label>Show Labels</label>
            <label class="toggle-switch">
                <input type="checkbox" id="label-toggle" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        
        <div class="control-group">
            <label>Export</label>
            <div class="export-buttons">
                <button id="export-pdf">PDF</button>
                <button id="export-svg">PNG</button>
            </div>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div id="context-menu" class="hidden">
        <div class="context-menu-item" id="isolate-node">Isolate</div>
        <div class="context-menu-item" id="copy-label">Copy Label</div>
        <div class="context-menu-item" id="cancel-isolate" style="display: none;">Cancel Isolate</div>
    </div>

    <script>
        // Sample 7-node directed graph data
        const GRAPH_DATA = {
  "metadata": {
    "title": "Target Graph with Subgraph Highlighted (Match)",
    "nodeCount": 15,
    "edgeCount": 32,
    "isDirected": false,
    "density": 0.3047619047619048
  },
  "nodes": [
    {
      "id": "0",
      "x": 10.895777651160863,
      "y": 186.88971486534325,
      "anchor": false,
      "label": "Subgraph: default",
      "display_label": "0",
      "color": "rgba(255, 0, 0, 0.8)"
    },
    {
      "id": "1",
      "x": 174.95386456672875,
      "y": 42.16305310815377,
      "anchor": false,
      "label": "Subgraph: default",
      "display_label": "1",
      "color": "rgba(255, 0, 0, 0.8)"
    },
    {
      "id": "2",
      "x": -92.77595092879099,
      "y": -90.83764703494886,
      "anchor": false,
      "label": "Subgraph: default",
      "display_label": "2",
      "color": "rgba(255, 0, 0, 0.8)"
    },
    {
      "id": "3",
      "x": -112.86053709515551,
      "y": 59.93244073144257,
      "anchor": false,
      "label": "Subgraph: default",
      "display_label": "3",
      "color": "rgba(255, 0, 0, 0.8)"
    },
    {
      "id": "4",
      "x": 85.45664970038794,
      "y": 65.52763419207123,
      "anchor": false,
      "label": "Target: default",
      "display_label": "4",
      "color": "rgba(59, 130, 246, 0.7)"
    },
    {
      "id": "5",
      "x": -128.3177492121866,
      "y": 156.97888646523313,
      "anchor": false,
      "label": "Target: default",
      "display_label": "5",
      "color": "rgba(59, 130, 246, 0.7)"
    },
    {
      "id": "6",
      "x": 174.78596854140923,
      "y": -23.419227175180772,
      "anchor": false,
      "label": "Subgraph: default",
      "display_label": "6",
      "color": "rgba(255, 0, 0, 0.8)"
    },
    {
      "id": "7",
      "x": -63.645469038210756,
      "y": -173.2422224640867,
      "anchor": false,
      "label": "Target: default",
      "display_label": "7",
      "color": "rgba(59, 130, 246, 0.7)"
    },
    {
      "id": "8",
      "x": -42.38555789102728,
      "y": 154.1492914714794,
      "anchor": false,
      "label": "Target: default",
      "display_label": "8",
      "color": "rgba(59, 130, 246, 0.7)"
    },
    {
      "id": "9",
      "x": 84.27555276445506,
      "y": -158.47601537902239,
      "anchor": false,
      "label": "Target: default",
      "display_label": "9",
      "color": "rgba(59, 130, 246, 0.7)"
    },
    {
      "id": "10",
      "x": 150.46377402218653,
      "y": -113.1299678878533,
      "anchor": false,
      "label": "Subgraph: default",
      "display_label": "10",
      "color": "rgba(255, 0, 0, 0.8)"
    },
    {
      "id": "11",
      "x": -162.4492492583445,
      "y": -73.46556295336273,
      "anchor": false,
      "label": "Target: default",
      "display_label": "11",
      "color": "rgba(59, 130, 246, 0.7)"
    },
    {
      "id": "12",
      "x": 78.18129373087342,
      "y": 156.70720116607137,
      "anchor": false,
      "label": "Target: default",
      "display_label": "12",
      "color": "rgba(59, 130, 246, 0.7)"
    },
    {
      "id": "13",
      "x": -181.0160948590188,
      "y": 10.222420894660232,
      "anchor": false,
      "label": "Target: default",
      "display_label": "13",
      "color": "rgba(59, 130, 246, 0.7)"
    },
    {
      "id": "14",
      "x": 24.437727305532654,
      "y": -200.0,
      "anchor": false,
      "label": "Target: default",
      "display_label": "14",
      "color": "rgba(59, 130, 246, 0.7)"
    }
  ],
  "edges": [
    {
      "source": "0",
      "target": "2",
      "directed": false,
      "label": "default"
    },
    {
      "source": "0",
      "target": "4",
      "directed": false,
      "label": "default"
    },
    {
      "source": "0",
      "target": "10",
      "directed": false,
      "label": "default"
    },
    {
      "source": "1",
      "target": "2",
      "directed": false,
      "label": "default"
    },
    {
      "source": "1",
      "target": "3",
      "directed": false,
      "label": "default"
    },
    {
      "source": "1",
      "target": "4",
      "directed": false,
      "label": "default"
    },
    {
      "source": "1",
      "target": "8",
      "directed": false,
      "label": "default"
    },
    {
      "source": "1",
      "target": "9",
      "directed": false,
      "label": "default"
    },
    {
      "source": "2",
      "target": "3",
      "directed": false,
      "label": "default"
    },
    {
      "source": "2",
      "target": "4",
      "directed": false,
      "label": "default"
    },
    {
      "source": "2",
      "target": "5",
      "directed": false,
      "label": "default"
    },
    {
      "source": "2",
      "target": "6",
      "directed": false,
      "label": "default"
    },
    {
      "source": "2",
      "target": "12",
      "directed": false,
      "label": "default"
    },
    {
      "source": "3",
      "target": "4",
      "directed": false,
      "label": "default"
    },
    {
      "source": "3",
      "target": "6",
      "directed": false,
      "label": "default"
    },
    {
      "source": "3",
      "target": "5",
      "directed": false,
      "label": "default"
    },
    {
      "source": "3",
      "target": "7",
      "directed": false,
      "label": "default"
    },
    {
      "source": "3",
      "target": "11",
      "directed": false,
      "label": "default"
    },
    {
      "source": "3",
      "target": "10",
      "directed": false,
      "label": "default"
    },
    {
      "source": "3",
      "target": "12",
      "directed": false,
      "label": "default"
    },
    {
      "source": "4",
      "target": "5",
      "directed": false,
      "label": "default"
    },
    {
      "source": "4",
      "target": "6",
      "directed": false,
      "label": "default"
    },
    {
      "source": "4",
      "target": "7",
      "directed": false,
      "label": "default"
    },
    {
      "source": "4",
      "target": "13",
      "directed": false,
      "label": "default"
    },
    {
      "source": "4",
      "target": "14",
      "directed": false,
      "label": "default"
    },
    {
      "source": "5",
      "target": "6",
      "directed": false,
      "label": "default"
    },
    {
      "source": "5",
      "target": "13",
      "directed": false,
      "label": "default"
    },
    {
      "source": "6",
      "target": "8",
      "directed": false,
      "label": "default"
    },
    {
      "source": "6",
      "target": "9",
      "directed": false,
      "label": "default"
    },
    {
      "source": "6",
      "target": "10",
      "directed": false,
      "label": "default"
    },
    {
      "source": "9",
      "target": "11",
      "directed": false,
      "label": "default"
    },
    {
      "source": "9",
      "target": "14",
      "directed": false,
      "label": "default"
    }
  ],
  "legend": {
    "nodeTypes": [
      {
        "label": "Target nodes",
        "color": "rgba(59, 130, 246, 0.7)"
      },
      {
        "label": "Subgraph nodes",
        "color": "rgba(255, 0, 0, 0.8)"
      }
    ],
    "edgeTypes": [
      {
        "label": "Edges",
        "color": "rgba(34, 100, 94, 0.7)"
      }
    ]
  }
};

        // Dynamic Style Management System
        class StyleManager {
            constructor() {
                this.nodeTypeColors = new Map();
                this.edgeTypeColors = new Map();
                this.discoveredNodeTypes = new Set();
                this.discoveredEdgeTypes = new Set();
                this.colorSeed = 0;
            }
            
            discoverTypes(nodes, edges) {
                // Clear previous discoveries for fresh analysis
                this.discoveredNodeTypes.clear();
                this.discoveredEdgeTypes.clear();
                
                // Discover all unique node types (excluding anchors as they have special handling)
                nodes.forEach(node => {
                    if (node.label && !node.anchor) {
                        this.discoveredNodeTypes.add(node.label);
                    }
                });
                
                // Discover all unique edge types
                edges.forEach(edge => {
                    if (edge.label) {
                        this.discoveredEdgeTypes.add(edge.label);
                    }
                });
                
                // Generate colors for discovered types
                this.generateColorsForTypes();
                
                // Update legend immediately after discovery
                this.updateLegend();
                
                // Validate requirements are met
                this.validateLegendRequirements();
                
                console.log(`Legend updated: ${this.discoveredNodeTypes.size} node types, ${this.discoveredEdgeTypes.size} edge types`);
            }
            
            generateColorsForTypes() {
                // Reset color seed for consistent color generation
                this.colorSeed = 0;
                
                // Generate colors for node types with better distribution
                const sortedNodeTypes = Array.from(this.discoveredNodeTypes).sort();
                sortedNodeTypes.forEach(type => {
                    if (!this.nodeTypeColors.has(type)) {
                        this.nodeTypeColors.set(type, this.generateLightTransparentColor(0.7));
                    }
                });
                
                // Generate colors for edge types with slightly more transparency
                const sortedEdgeTypes = Array.from(this.discoveredEdgeTypes).sort();
                sortedEdgeTypes.forEach(type => {
                    if (!this.edgeTypeColors.has(type)) {
                        this.edgeTypeColors.set(type, this.generateLightTransparentColor(0.6));
                    }
                });
            }
            
            generateLightTransparentColor(alpha = 0.7) {
                // Use golden angle for optimal color distribution
                const hue = (this.colorSeed * 137.508) % 360;
                
                // Ensure good saturation and lightness for readability
                const saturation = 50 + (this.colorSeed * 19) % 25; // 50-75% saturation
                const lightness = 65 + (this.colorSeed * 13) % 20; // 65-85% lightness
                
                this.colorSeed++;
                
                // Convert HSL to RGB
                const rgb = this.hslToRgb(hue / 360, saturation / 100, lightness / 100);
                return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            }
            
            hslToRgb(h, s, l) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
            
            getNodeColor(type) {
                if (!type) type = 'default';
                
                if (!this.nodeTypeColors.has(type)) {
                    this.nodeTypeColors.set(type, this.generateLightTransparentColor(0.7));
                    this.discoveredNodeTypes.add(type);
                    this.updateLegend();
                }
                
                return this.nodeTypeColors.get(type);
            }
            
            getEdgeColor(type) {
                if (!type) type = 'default';
                
                if (!this.edgeTypeColors.has(type)) {
                    this.edgeTypeColors.set(type, this.generateLightTransparentColor(0.6));
                    this.discoveredEdgeTypes.add(type);
                    this.updateLegend();
                }
                
                return this.edgeTypeColors.get(type);
            }
            
            // Method to force legend refresh - useful for external calls
            refreshLegend() {
                this.updateLegend();
            }
            
            // Validate that legend meets all requirements
            validateLegendRequirements() {
                const legendContent = document.getElementById('legend-content');
                const results = {
                    requirement_5_1: !!legendContent, // Legend card exists
                    requirement_5_2: this.discoveredNodeTypes.size > 0, // Node types shown
                    requirement_5_3: this.discoveredEdgeTypes.size > 0, // Edge types shown
                    requirement_5_4: legendContent.innerHTML.includes('Anchor Nodes'), // Anchor indication
                    proper_spacing: legendContent.querySelectorAll('.legend-section').length > 0,
                    color_mapping: this.nodeTypeColors.size > 0 || this.edgeTypeColors.size > 0
                };
                
                console.log('Legend Requirements Validation:', results);
                return results;
            }
            
            updateLegend() {
                const legendContent = document.getElementById('legend-content');
                if (!legendContent) return;
                
                // Clear existing content
                legendContent.innerHTML = '';
                
                // Create legend sections with proper spacing and readability
                this.createNodeTypesLegend(legendContent);
                this.createEdgeTypesLegend(legendContent);
                this.createAnchorNodesLegend(legendContent);
            }
            
            createNodeTypesLegend(legendContent) {
                if (this.discoveredNodeTypes.size === 0) return;
                
                const nodeSection = document.createElement('div');
                nodeSection.className = 'legend-section';
                
                const header = document.createElement('h4');
                header.textContent = 'Node Types';
                nodeSection.appendChild(header);
                
                // Sort node types alphabetically for consistent display
                const sortedNodeTypes = Array.from(this.discoveredNodeTypes).sort();
                
                sortedNodeTypes.forEach(type => {
                    const color = this.nodeTypeColors.get(type);
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = color;
                    
                    const label = document.createElement('span');
                    label.textContent = type;
                    
                    item.appendChild(colorBox);
                    item.appendChild(label);
                    nodeSection.appendChild(item);
                });
                
                legendContent.appendChild(nodeSection);
            }
            
            createEdgeTypesLegend(legendContent) {
                if (this.discoveredEdgeTypes.size === 0) return;
                
                const edgeSection = document.createElement('div');
                edgeSection.className = 'legend-section';
                
                const header = document.createElement('h4');
                header.textContent = 'Edge Types';
                edgeSection.appendChild(header);
                
                // Sort edge types alphabetically for consistent display
                const sortedEdgeTypes = Array.from(this.discoveredEdgeTypes).sort();
                
                sortedEdgeTypes.forEach(type => {
                    const color = this.edgeTypeColors.get(type);
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = color;
                    
                    const label = document.createElement('span');
                    label.textContent = type;
                    
                    item.appendChild(colorBox);
                    item.appendChild(label);
                    edgeSection.appendChild(item);
                });
                
                legendContent.appendChild(edgeSection);
            }
            
            createAnchorNodesLegend(legendContent) {
                // Always show anchor nodes section as per requirement 5.4
                const anchorSection = document.createElement('div');
                anchorSection.className = 'legend-section';
                
                const header = document.createElement('h4');
                header.textContent = 'Special Nodes';
                anchorSection.appendChild(header);
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-shape';
                colorBox.style.backgroundColor = 'rgba(239, 68, 68, 0.8)';
                colorBox.style.borderRadius = '2px'; // Make it more square-like
                
                const label = document.createElement('span');
                label.textContent = 'Anchor Nodes';
                
                item.appendChild(colorBox);
                item.appendChild(label);
                anchorSection.appendChild(item);
                
                legendContent.appendChild(anchorSection);
            }
            
            getTypeStatistics() {
                return {
                    nodeTypes: Array.from(this.discoveredNodeTypes),
                    edgeTypes: Array.from(this.discoveredEdgeTypes),
                    nodeTypeCount: this.discoveredNodeTypes.size,
                    edgeTypeCount: this.discoveredEdgeTypes.size
                };
            }
        }

        class GraphLayoutEngine {
            constructor() {
                this.minDistance = 460; // Minimum distance between nodes
                this.iterations = 100; // Layout algorithm iterations
                this.repulsionStrength = 1000;
                this.attractionStrength = 0.1;
                this.damping = 0.9;
            }
            
            applyForceDirectedLayout(nodes, edges) {
                // Create node lookup
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                    // Initialize velocity if not present
                    if (!node.vx) node.vx = 0;
                    if (!node.vy) node.vy = 0;
                });
                
                // Apply force-directed layout algorithm
                for (let iter = 0; iter < this.iterations; iter++) {
                    // Reset forces
                    nodes.forEach(node => {
                        node.fx = 0;
                        node.fy = 0;
                    });
                    
                    // Apply repulsion forces between all nodes
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            this.applyRepulsion(nodes[i], nodes[j]);
                        }
                    }
                    
                    // Apply attraction forces along edges
                    edges.forEach(edge => {
                        const source = nodeMap[edge.source];
                        const target = nodeMap[edge.target];
                        if (source && target) {
                            this.applyAttraction(source, target);
                        }
                    });
                    
                    // Update positions
                    nodes.forEach(node => {
                        if (!node.anchor) { // Don't move anchor nodes
                            node.vx = (node.vx + node.fx) * this.damping;
                            node.vy = (node.vy + node.fy) * this.damping;
                            node.x += node.vx;
                            node.y += node.vy;
                        }
                    });
                }
                
                // Clean up temporary properties
                nodes.forEach(node => {
                    delete node.fx;
                    delete node.fy;
                    delete node.vx;
                    delete node.vy;
                });
            }
            
            applyRepulsion(node1, node2) {
                const dx = node2.x - node1.x;
                const dy = node2.y - node1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0 && distance < this.minDistance * 3) {
                    const force = this.repulsionStrength / (distance * distance);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    
                    node1.fx -= fx;
                    node1.fy -= fy;
                    node2.fx += fx;
                    node2.fy += fy;
                }
            }
            
            applyAttraction(source, target) {
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > this.minDistance) {
                    const force = this.attractionStrength * (distance - this.minDistance);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    
                    source.fx += fx;
                    source.fy += fy;
                    target.fx -= fx;
                    target.fy -= fy;
                }
            }
            
            generateInitialLayout(nodes, edges) {
                // Generate initial positions if not provided
                const radius = Math.max(100, nodes.length * 15);
                
                nodes.forEach((node, index) => {
                    if (node.x === undefined || node.y === undefined) {
                        if (node.anchor) {
                            // Place anchor nodes at origin or specific positions
                            node.x = 0;
                            node.y = 0;
                        } else {
                            // Distribute other nodes in a circle
                            const angle = (index * 2 * Math.PI) / nodes.length;
                            node.x = Math.cos(angle) * radius;
                            node.y = Math.sin(angle) * radius;
                        }
                    }
                });
                
                // Apply force-directed layout to improve positioning
                this.applyForceDirectedLayout(nodes, edges);
            }
            // Add this to your GraphLayoutEngine class

            generateConcentricLayout(nodes, edges, minLayerDistance = 380) {
                // 1. Build adjacency and degree maps
                const nodeMap = {};
                const degreeMap = {};
                const neighborsMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                    degreeMap[node.id] = 0;
                    neighborsMap[node.id] = [];
                });
                edges.forEach(edge => {
                    if (nodeMap[edge.source] && nodeMap[edge.target]) {
                        degreeMap[edge.source]++;
                        degreeMap[edge.target]++;
                        neighborsMap[edge.source].push(edge.target);
                        if (!edge.directed) {
                            neighborsMap[edge.target].push(edge.source);
                        }
                    }
                });

                // 2. Find highest degree node
                let centerNodeId = nodes[0].id;
                let maxDegree = -1;
                for (const id in degreeMap) {
                    if (degreeMap[id] > maxDegree) {
                        maxDegree = degreeMap[id];
                        centerNodeId = id;
                    }
                }

                // 3. BFS to assign layers and parents
                const distances = {};
                const allParents = {};
                const primaryParent = {};
                const visited = new Set();
                const queue = [];
                distances[centerNodeId] = 0;
                allParents[centerNodeId] = [];
                primaryParent[centerNodeId] = null;
                queue.push(centerNodeId);
                visited.add(centerNodeId);

                while (queue.length > 0) {
                    const nodeId = queue.shift();
                    const dist = distances[nodeId];
                    const neighbors = neighborsMap[nodeId] || [];
                    neighbors.forEach(neighborId => {
                        if (!visited.has(neighborId)) {
                            distances[neighborId] = dist + 1;
                            allParents[neighborId] = [nodeId];
                            primaryParent[neighborId] = nodeId;
                            queue.push(neighborId);
                            visited.add(neighborId);
                        } else if (distances[neighborId] === dist + 1) {
                            if (!allParents[neighborId]) allParents[neighborId] = [];
                            allParents[neighborId].push(nodeId);
                        }
                    });
                }

                // 4. Group nodes by layer
                const layers = {};
                for (const nodeId in distances) {
                    const d = distances[nodeId];
                    if (!layers[d]) layers[d] = [];
                    layers[d].push(nodeId);
                }

                // 5. Layout parameters
                const numNodes = nodes.length;
                let baseRadius;
                const radiusIncrement = Math.max(minLayerDistance, numNodes <= 8 ? 140 : 90);
                if (numNodes <= 5) {
                    baseRadius = 280;
                } else if (numNodes <= 10) {
                    baseRadius = 350;
                } else if (numNodes <= 15) {
                    baseRadius = 350;
                } else if (numNodes <= 20) {
                    baseRadius = 560;
                } else {
                    baseRadius = 640;
                }

                // 6. Assign positions
                const pos = {};
                pos[centerNodeId] = { x: 0, y: 0 };

                // Layer 1: arrange in a circle
                if (layers[1]) {
                    const layer1 = layers[1];
                    layer1.sort((a, b) => degreeMap[b] - degreeMap[a] || a.localeCompare(b));
                    const n = layer1.length;
                    for (let i = 0; i < n; i++) {
                        const angle = 2 * Math.PI * i / n;
                        pos[layer1[i]] = {
                            x: baseRadius * Math.cos(angle),
                            y: baseRadius * Math.sin(angle)
                        };
                    }
                }

                // Layers 2+
                const maxLayer = Math.max(...Object.keys(layers).map(Number));
                for (let layer = 2; layer <= maxLayer; layer++) {
                    if (!layers[layer]) continue;
                    const nodesInLayer = layers[layer];
                    nodesInLayer.forEach(nodeId => {
                        const parents = allParents[nodeId] || [];
                        if (parents.length === 1) {
                            // Single parent: radial from center through parent
                            const parentPos = pos[parents[0]];
                            const norm = Math.sqrt(parentPos.x * parentPos.x + parentPos.y * parentPos.y);
                            const radialDir = norm > 0 ? { x: parentPos.x / norm, y: parentPos.y / norm } : { x: 1, y: 0 };
                            let layerDist = baseRadius + (layer - 1) * radiusIncrement;
                            // Sibling spread
                            const siblings = nodesInLayer.filter(nid => (allParents[nid] || []).length === 1 && allParents[nid][0] === parents[0]);
                            let offset = 0;
                            if (siblings.length > 1) {
                                const idx = siblings.indexOf(nodeId);
                                const spread = Math.min(80, layerDist * 0.3);
                                const perpDir = { x: -radialDir.y, y: radialDir.x };
                                offset = (idx - (siblings.length - 1) / 2) * (spread / Math.max(1, siblings.length - 1));
                                pos[nodeId] = {
                                    x: radialDir.x * layerDist + perpDir.x * offset,
                                    y: radialDir.y * layerDist + perpDir.y * offset
                                };
                            } else {
                                pos[nodeId] = {
                                    x: radialDir.x * layerDist,
                                    y: radialDir.y * layerDist
                                };
                            }
                        } else if (parents.length > 1) {
                            // Multiple parents: centroid, then move outward
                            let centroid = { x: 0, y: 0 };
                            let count = 0;
                            parents.forEach(pid => {
                                if (pos[pid]) {
                                    centroid.x += pos[pid].x;
                                    centroid.y += pos[pid].y;
                                    count++;
                                }
                            });
                            if (count > 0) {
                                centroid.x /= count;
                                centroid.y /= count;
                            }
                            const norm = Math.sqrt(centroid.x * centroid.x + centroid.y * centroid.y);
                            const direction = norm > 0 ? { x: centroid.x / norm, y: centroid.y / norm } : { x: 1, y: 0 };
                            let layerDist = baseRadius + (layer - 1) * radiusIncrement;
                            // For diamond patterns, bring closer
                            if (parents.length === 2 && count === 2) {
                                // Check if parents are far apart
                                const p1 = pos[parents[0]], p2 = pos[parents[1]];
                                const n1 = Math.sqrt(p1.x * p1.x + p1.y * p1.y);
                                const n2 = Math.sqrt(p2.x * p2.x + p2.y * p2.y);
                                if (n1 > 0 && n2 > 0) {
                                    const dir1 = { x: p1.x / n1, y: p1.y / n1 };
                                    const dir2 = { x: p2.x / n2, y: p2.y / n2 };
                                    const dot = dir1.x * dir2.x + dir1.y * dir2.y;
                                    const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
                                    if (angle > Math.PI / 2) {
                                        layerDist *= 0.8;
                                    }
                                }
                            }
                            pos[nodeId] = {
                                x: direction.x * layerDist,
                                y: direction.y * layerDist
                            };
                        }
                    });
                }

                // 7. Assign positions to node objects
                nodes.forEach(node => {
                    if (pos[node.id]) {
                        node.x = pos[node.id].x;
                        node.y = pos[node.id].y;
                    }
                });
            }   
        }

        class CanvasNavigator {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                
                // Transform state
                this.transform = { x: 0, y: 0, scale: 1 };
                
                // Animation state
                this.animationId = null;
                this.isAnimating = false;
                
                // Canvas interaction state
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                // Node interaction state
                this.isDraggingNode = false;
                this.draggedNode = null;
                this.hoveredNode = null;
                this.selectedNode = null;
                this.nodeZOrder = []; // Track node layering for overlapping
                
                // Context menu and isolation state
                this.contextMenuNode = null;
                this.isolatedNode = null;
                this.contextMenu = document.getElementById('context-menu');
                
                // Configuration
                this.minZoom = 0.1;
                this.maxZoom = 5.0;
                this.zoomStep = 0.2;
                this.animationDuration = 300; // ms
                this.nodeRadius = 50;
                this.hoverRadius = 25; // Slightly larger for easier interaction
                
                this.setupEventListeners();
                this.render();
            }
            
            setupEventListeners() {
                // Mouse events for canvas and node interaction
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                
                // Wheel event for zoom
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                
                // Zoom control buttons
                document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());
                document.getElementById('recenter').addEventListener('click', () => this.recenter());
                
                // Context menu event handlers
                this.setupContextMenuHandlers();
            }
            
            handleMouseDown(e) {
                if (e.button === 0) { // Left mouse button
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldPos = this.screenToWorld(mouseX, mouseY);
                    
                    // Check if clicking on a node
                    const clickedNode = this.getNodeAtPosition(worldPos.x, worldPos.y);
                    
                    if (clickedNode) {
                        // Start node dragging
                        this.isDraggingNode = true;
                        this.draggedNode = clickedNode;
                        this.selectedNode = clickedNode;
                        
                        // Bring node to front in z-order
                        this.bringNodeToFront(clickedNode);
                        
                        this.canvas.style.cursor = 'grabbing';
                        this.render(); // Re-render to show selection
                    } else {
                        // Start canvas dragging
                        this.isDragging = true;
                        this.selectedNode = null; // Clear selection
                        this.canvas.style.cursor = 'grabbing';
                    }
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                }
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(mouseX, mouseY);
                
                if (this.isDraggingNode && this.draggedNode) {
                    // Update node position with smooth movement
                    this.draggedNode.x = worldPos.x;
                    this.draggedNode.y = worldPos.y;
                    
                    // Ensure dragged node stays on top
                    this.bringNodeToFront(this.draggedNode);
                    
                    this.render(); // Re-render to show node movement and edge updates
                } else if (this.isDragging) {
                    // Canvas panning
                    const deltaX = e.clientX - this.lastMouseX;
                    const deltaY = e.clientY - this.lastMouseY;
                    
                    this.transform.x += deltaX;
                    this.transform.y += deltaY;
                    
                    this.render();
                } else {
                    // Handle hover effects with smooth transitions
                    const hoveredNode = this.getNodeAtPosition(worldPos.x, worldPos.y);
                    
                    if (hoveredNode !== this.hoveredNode) {
                        this.hoveredNode = hoveredNode;
                        
                        // Update cursor based on hover state
                        if (hoveredNode) {
                            this.canvas.style.cursor = 'pointer';
                        } else {
                            this.canvas.style.cursor = 'grab';
                        }
                        
                        this.render(); // Re-render to show hover effects
                    }
                }
                
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }
            
            handleMouseUp(e) {
                if (this.isDraggingNode) {
                    this.isDraggingNode = false;
                    this.draggedNode = null;
                    
                    // Update cursor based on current hover state
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldPos = this.screenToWorld(mouseX, mouseY);
                    const hoveredNode = this.getNodeAtPosition(worldPos.x, worldPos.y);
                    
                    this.canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
                } else if (this.isDragging) {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                }
            }
            
            handleClick(e) {
                // Handle node focus for overlapping nodes
                if (!this.isDraggingNode && !this.isDragging) {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldPos = this.screenToWorld(mouseX, mouseY);
                    
                    const clickedNode = this.getNodeAtPosition(worldPos.x, worldPos.y);
                    
                    if (clickedNode) {
                        // If clicking on a node that's underneath another, bring it to front
                        this.selectedNode = clickedNode;
                        this.bringNodeToFront(clickedNode);
                        this.render();
                    }
                }
                
                // Hide context menu on any click
                this.hideContextMenu();
            }
            
            handleRightClick(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(mouseX, mouseY);
                
                const clickedNode = this.getNodeAtPosition(worldPos.x, worldPos.y);
                
                if (clickedNode) {
                    // Show context menu for the clicked node
                    this.showContextMenu(e.clientX, e.clientY, clickedNode);
                } else {
                    // Hide context menu if right-clicking on empty space
                    this.hideContextMenu();
                }
            }
            
            setupContextMenuHandlers() {
                // Isolate node functionality
                document.getElementById('isolate-node').addEventListener('click', () => {
                    if (this.contextMenuNode) {
                        this.isolateNode(this.contextMenuNode);
                        this.hideContextMenu();
                    }
                });
                
                // Copy label functionality
                document.getElementById('copy-label').addEventListener('click', () => {
                    if (this.contextMenuNode) {
                        this.copyNodeLabel(this.contextMenuNode);
                        this.hideContextMenu();
                    }
                });
                
                // Cancel isolation functionality
                document.getElementById('cancel-isolate').addEventListener('click', () => {
                    this.cancelIsolation();
                    this.hideContextMenu();
                });
                
                // Hide context menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!this.contextMenu.contains(e.target)) {
                        this.hideContextMenu();
                    }
                });
            }
            
            showContextMenu(x, y, node) {
                this.contextMenuNode = node;
                
                // Update context menu items based on current state
                const isolateItem = document.getElementById('isolate-node');
                const cancelIsolateItem = document.getElementById('cancel-isolate');
                
                if (this.isolatedNode === node) {
                    // If this node is already isolated, show cancel option
                    isolateItem.style.display = 'none';
                    cancelIsolateItem.style.display = 'block';
                } else {
                    // Show isolate option
                    isolateItem.style.display = 'block';
                    cancelIsolateItem.style.display = 'none';
                }
                
                // Position context menu
                this.contextMenu.style.left = x + 'px';
                this.contextMenu.style.top = y + 'px';
                this.contextMenu.classList.remove('hidden');
                
                // Ensure context menu stays within viewport
                const rect = this.contextMenu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    this.contextMenu.style.left = (x - rect.width) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    this.contextMenu.style.top = (y - rect.height) + 'px';
                }
            }
            
            hideContextMenu() {
                this.contextMenu.classList.add('hidden');
                this.contextMenuNode = null;
            }
            
            isolateNode(node) {
                this.isolatedNode = node;
                console.log(`Isolated node: ${node.label || node.id}`);
                this.render(); // Re-render to apply isolation effects
            }
            
            cancelIsolation() {
                this.isolatedNode = null;
                console.log('Isolation cancelled');
                this.render(); // Re-render to remove isolation effects
            }
            
            copyNodeLabel(node) {
                // Copy only the label (or id) of the specific node
                const label = node.display_label || node.label;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(label).then(() => {
                        console.log('Node label copied to clipboard');
                        this.showCopyFeedback();
                    }).catch(err => {
                        console.error('Failed to copy to clipboard:', err);
                        this.fallbackCopyToClipboard(label);
                    });
                } else {
                    this.fallbackCopyToClipboard(label);
                }
            }
            
            fallbackCopyToClipboard(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    console.log('All node labels copied to clipboard (fallback)');
                    this.showCopyFeedback();
                } catch (err) {
                    console.error('Fallback copy failed:', err);
                    alert('Copy to clipboard failed. Please copy manually.');
                }
                
                document.body.removeChild(textArea);
            }
            
            showCopyFeedback() {
                // Create temporary feedback element
                const feedback = document.createElement('div');
                feedback.textContent = 'Labels copied to clipboard!';
                feedback.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: var(--card-bg);
                    border: 1px solid var(--card-border);
                    border-radius: 6px;
                    padding: 12px 20px;
                    box-shadow: var(--card-shadow);
                    z-index: 3000;
                    font-size: 14px;
                    color: var(--text-primary);
                    backdrop-filter: blur(10px);
                `;
                
                document.body.appendChild(feedback);
                
                // Remove feedback after 2 seconds
                setTimeout(() => {
                    if (feedback.parentNode) {
                        document.body.removeChild(feedback);
                    }
                }, 2000);
            }
            
            getTestNodes() {
                // Return test nodes for fallback
                return [
                    {id: 'origin', label: 'Origin'},
                    {id: 'processor', label: 'Processor'},
                    {id: 'database', label: 'Database'},
                    {id: 'api', label: 'API Gateway'},
                    {id: 'cache', label: 'Cache'},
                    {id: 'monitor', label: 'Monitor'},
                    {id: 'queue', label: 'Message Queue'},
                    {id: 'auth', label: 'Auth Service'}
                ];
            }
            
            isNodeConnectedToIsolated(node) {
                if (!this.isolatedNode) return false;
                
                const edges = GRAPH_DATA && GRAPH_DATA.edges ? GRAPH_DATA.edges : this.getTestEdges();
                
                // Check if this node is directly connected to the isolated node
                return edges.some(edge => 
                    (edge.source === this.isolatedNode.id && edge.target === node.id) ||
                    (edge.target === this.isolatedNode.id && edge.source === node.id)
                );
            }
            
            isEdgeConnectedToIsolated(edge) {
                if (!this.isolatedNode) return false;
                
                // Check if this edge is directly connected to the isolated node
                return edge.source === this.isolatedNode.id || edge.target === this.isolatedNode.id;
            }
            
            getTestEdges() {
                // Return test edges for fallback
                return [
                    {source: 'origin', target: 'processor'},
                    {source: 'origin', target: 'database'},
                    {source: 'processor', target: 'api'},
                    {source: 'database', target: 'cache'},
                    {source: 'api', target: 'monitor'},
                    {source: 'cache', target: 'queue'},
                    {source: 'monitor', target: 'queue'},
                    {source: 'api', target: 'auth'}
                ];
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Determine zoom direction
                const zoomDirection = e.deltaY > 0 ? -1 : 1;
                const zoomFactor = 1 + (this.zoomStep * zoomDirection);
                
                this.zoomAtPoint(mouseX, mouseY, zoomFactor);
            }
            
            zoomIn() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const zoomFactor = 1 + this.zoomStep;
                
                this.animateZoomAtPoint(centerX, centerY, zoomFactor);
            }
            
            zoomOut() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const zoomFactor = 1 - this.zoomStep;
                
                this.animateZoomAtPoint(centerX, centerY, zoomFactor);
            }
            
            zoomAtPoint(mouseX, mouseY, zoomFactor) {
                const newScale = Math.max(this.minZoom, Math.min(this.maxZoom, this.transform.scale * zoomFactor));
                
                if (newScale !== this.transform.scale) {
                    // Calculate zoom point in world coordinates
                    const worldX = (mouseX - this.transform.x) / this.transform.scale;
                    const worldY = (mouseY - this.transform.y) / this.transform.scale;
                    
                    // Update scale
                    this.transform.scale = newScale;
                    
                    // Adjust position to keep zoom point fixed
                    this.transform.x = mouseX - worldX * this.transform.scale;
                    this.transform.y = mouseY - worldY * this.transform.scale;
                    
                    this.render();
                }
            }
            
            animateZoomAtPoint(mouseX, mouseY, zoomFactor) {
                const targetScale = Math.max(this.minZoom, Math.min(this.maxZoom, this.transform.scale * zoomFactor));
                
                if (targetScale === this.transform.scale) return;
                
                // Calculate target transform
                const worldX = (mouseX - this.transform.x) / this.transform.scale;
                const worldY = (mouseY - this.transform.y) / this.transform.scale;
                const targetX = mouseX - worldX * targetScale;
                const targetY = mouseY - worldY * targetScale;
                
                this.animateTransform(targetX, targetY, targetScale);
            }
            
            recenter() {
                // Animate back to center position with scale 1
                this.animateTransform(0, 0, 1);
            }
            
            animateTransform(targetX, targetY, targetScale) {
                if (this.isAnimating) {
                    cancelAnimationFrame(this.animationId);
                }
                
                const startTime = performance.now();
                const startX = this.transform.x;
                const startY = this.transform.y;
                const startScale = this.transform.scale;
                
                const deltaX = targetX - startX;
                const deltaY = targetY - startY;
                const deltaScale = targetScale - startScale;
                
                this.isAnimating = true;
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / this.animationDuration, 1);
                    
                    // Easing function (ease-out)
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    this.transform.x = startX + deltaX * easeOut;
                    this.transform.y = startY + deltaY * easeOut;
                    this.transform.scale = startScale + deltaScale * easeOut;
                    
                    this.render();
                    
                    if (progress < 1) {
                        this.animationId = requestAnimationFrame(animate);
                    } else {
                        this.isAnimating = false;
                    }
                };
                
                this.animationId = requestAnimationFrame(animate);
            }
            
            applyTransform() {
                this.ctx.setTransform(
                    this.transform.scale, 0, 0, this.transform.scale,
                    this.transform.x, this.transform.y
                );
            }
            
            resetTransform() {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            
            render() {
                // Clear canvas
                this.resetTransform();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Apply transform for graph content
                this.applyTransform();

                // Draw graph content
                this.drawGraph();

                // Draw node labels in world coordinates (with transform applied)
                if (window.labelsEnabled) {
                    this.drawNodeLabels(GRAPH_DATA.nodes);
                }

                // Reset transform for UI overlays if needed
                this.resetTransform();
            }
            

            
            drawGraph() {
                // Draw aesthetic grid background that transforms with canvas navigation
                this.drawGrid();
                
                // Draw graph content using the graph rendering engine
                if (GRAPH_DATA && GRAPH_DATA.nodes && GRAPH_DATA.edges) {
                    this.drawEdges(GRAPH_DATA.edges, GRAPH_DATA.nodes);
                    this.drawNodes(GRAPH_DATA.nodes);
                    
                    // Draw labels if enabled
                    if (window.labelsEnabled) {
                        this.drawNodeLabels(GRAPH_DATA.nodes);
                        this.drawEdgeLabels(GRAPH_DATA.edges, GRAPH_DATA.nodes);
                    }
                } else {
                    // Fallback: draw test nodes if no graph data is available
                    this.drawTestGraph();
                }
            }
            
            drawTestGraph() {
                // Enhanced test graph with diverse types and custom metadata
                const testNodes = [
                    {
                        id: 'origin', 
                        x: 0, y: 0, 
                        type: 'anchor', 
                        label: 'Origin', 
                        anchor: true,
                        metadata: {
                            importance: 'high',
                            category: 'root',
                            created: '2024-01-01'
                        }
                    },
                    {
                        id: 'processor', 
                        x: 120, y: 60, 
                        type: 'computation', 
                        label: 'Processor', 
                        anchor: false,
                        metadata: {
                            cpu_usage: '75%',
                            memory: '2GB',
                            status: 'active'
                        }
                    },
                    {
                        id: 'database', 
                        x: -90, y: 140, 
                        type: 'storage', 
                        label: 'Database', 
                        anchor: false,
                        metadata: {
                            size: '500MB',
                            connections: 12,
                            type: 'postgresql'
                        }
                    },
                    {
                        id: 'api', 
                        x: 180, y: -120, 
                        type: 'service', 
                        label: 'API Gateway', 
                        anchor: false,
                        metadata: {
                            requests_per_sec: 150,
                            uptime: '99.9%',
                            version: '2.1.0'
                        }
                    },
                    {
                        id: 'cache', 
                        x: -140, y: -90, 
                        type: 'storage', 
                        label: 'Cache', 
                        anchor: false,
                        metadata: {
                            hit_rate: '85%',
                            size: '128MB',
                            ttl: '3600s'
                        }
                    },
                    {
                        id: 'monitor', 
                        x: 60, y: -180, 
                        type: 'analytics', 
                        label: 'Monitor', 
                        anchor: false,
                        metadata: {
                            alerts: 3,
                            metrics: 45,
                            status: 'healthy'
                        }
                    },
                    {
                        id: 'queue', 
                        x: -60, y: 180, 
                        type: 'messaging', 
                        label: 'Message Queue', 
                        anchor: false,
                        metadata: {
                            messages: 1250,
                            consumers: 5,
                            lag: '2ms'
                        }
                    },
                    {
                        id: 'auth', 
                        x: 200, y: 80, 
                        type: 'security', 
                        label: 'Auth Service', 
                        anchor: false,
                        metadata: {
                            active_sessions: 89,
                            token_expiry: '24h',
                            mfa_enabled: true
                        }
                    }
                ];
                
                const testEdges = [
                    {
                        source: 'origin', 
                        target: 'processor', 
                        type: 'data_flow', 
                        directed: true, 
                        label: 'processes',
                        metadata: {
                            bandwidth: '100Mbps',
                            latency: '5ms',
                            protocol: 'TCP'
                        }
                    },
                    {
                        source: 'origin', 
                        target: 'database', 
                        type: 'query', 
                        directed: true, 
                        label: 'queries',
                        metadata: {
                            query_type: 'SELECT',
                            frequency: '50/sec',
                            avg_time: '12ms'
                        }
                    },
                    {
                        source: 'processor', 
                        target: 'api', 
                        type: 'http_request', 
                        directed: false, 
                        label: 'communicates',
                        metadata: {
                            method: 'POST',
                            content_type: 'application/json',
                            auth_required: true
                        }
                    },
                    {
                        source: 'database', 
                        target: 'cache', 
                        type: 'cache_sync', 
                        directed: true,
                        metadata: {
                            sync_interval: '30s',
                            compression: 'gzip',
                            encryption: true
                        }
                    },
                    {
                        source: 'api', 
                        target: 'monitor', 
                        type: 'telemetry', 
                        directed: true, 
                        label: 'reports',
                        metadata: {
                            metrics_format: 'prometheus',
                            interval: '10s',
                            retention: '30d'
                        }
                    },
                    {
                        source: 'cache', 
                        target: 'queue', 
                        type: 'event_stream', 
                        directed: false,
                        metadata: {
                            event_type: 'cache_invalidation',
                            format: 'json',
                            reliability: 'at_least_once'
                        }
                    },
                    {
                        source: 'monitor', 
                        target: 'queue', 
                        type: 'alert', 
                        directed: true,
                        label: 'alerts',
                        metadata: {
                            severity: 'warning',
                            channel: 'slack',
                            escalation: '5min'
                        }
                    },
                    {
                        source: 'api', 
                        target: 'auth', 
                        type: 'authentication', 
                        directed: true,
                        label: 'validates',
                        metadata: {
                            method: 'JWT',
                            algorithm: 'RS256',
                            refresh_token: true
                        }
                    }
                ];
                
                // Discover types and generate colors
                if (window.styleManager) {
                    window.styleManager.discoverTypes(testNodes, testEdges);
                }
                
                // Apply layout algorithm to test nodes
                if (window.layoutEngine) {
                    // window.layoutEngine.generateInitialLayout(testNodes, testEdges);
                    window.layoutEngine.generateConcentricLayout(GRAPH_DATA.nodes, GRAPH_DATA.edges);
                }
                
                this.drawEdges(testEdges, testNodes);
                this.drawNodes(testNodes);
                
                if (window.labelsEnabled) {
                    this.drawNodeLabels(testNodes);
                    this.drawEdgeLabels(testEdges, testNodes);
                }
            }
            
            drawNodes(nodes) {
                const ctx = this.ctx;
                const nodeRadius = 50;
                const baseLineWidth = 3 / this.transform.scale;
                
                // Draw nodes in z-order (bottom to top)
                const orderedNodes = this.getNodesInZOrder(nodes);
                
                orderedNodes.forEach(node => {
                    let nodeColor = this.getNodeColor(node);
                    let borderColor = this.getNodeBorderColor(node);
                    let lineWidth = baseLineWidth;
                    let radius = nodeRadius;
                    let size = nodeRadius * 1.2;
                    
                    // Apply isolation effects
                    const isIsolated = this.isolatedNode !== null;
                    const isIsolatedNode = this.isolatedNode && this.isolatedNode.id === node.id;
                    const isConnectedToIsolated = isIsolated && !isIsolatedNode && this.isNodeConnectedToIsolated(node);
                    
                    if (isIsolated && !isIsolatedNode && !isConnectedToIsolated) {
                        // Apply blur and opacity reduction to non-connected nodes
                        ctx.filter = 'blur(2px)';
                        nodeColor = nodeColor.replace(/[\d\.]+\)$/, '0.3)'); // Reduce opacity
                        borderColor = borderColor.replace(/[\d\.]+\)$/, '0.3)');
                    } else {
                        ctx.filter = 'none';
                    }
                    
                    // Apply visual feedback for interaction states
                    const isHovered = this.hoveredNode && this.hoveredNode.id === node.id;
                    const isSelected = this.selectedNode && this.selectedNode.id === node.id;
                    const isDragged = this.draggedNode && this.draggedNode.id === node.id;
                    
                    // Enhance visual feedback for different states
                    if (isDragged) {
                        // Dragged node: larger, brighter border, slight glow effect
                        lineWidth = baseLineWidth * 2;
                        borderColor = 'rgba(59, 130, 246, 0.8)';
                        radius = nodeRadius * 1.1;
                        size = nodeRadius * 1.3;
                        
                        // Add glow effect
                        ctx.shadowColor = 'rgba(59, 130, 246, 0.4)';
                        ctx.shadowBlur = 10 / this.transform.scale;
                    } else if (isSelected) {
                        // Selected node: thicker border, slightly larger
                        lineWidth = baseLineWidth * 1.5;
                        borderColor = 'rgba(59, 130, 246, 0.6)';
                        radius = nodeRadius * 1.05;
                        size = nodeRadius * 1.25;
                    } else if (isHovered) {
                        // Hovered node: subtle highlight
                        lineWidth = baseLineWidth * 1.2;
                        borderColor = 'rgba(59, 130, 246, 0.4)';
                        radius = nodeRadius * 1.02;
                        size = nodeRadius * 1.22;
                    }
                    
                    ctx.lineWidth = lineWidth;
                    ctx.fillStyle = nodeColor;
                    ctx.strokeStyle = borderColor;
                    
                    if (node.anchor) {
                        // Draw anchor nodes as red squares
                        ctx.fillRect(node.x - size, node.y - size, size * 2, size * 2);
                        ctx.strokeRect(node.x - size, node.y - size, size * 2, size * 2);
                    } else {
                        // Draw regular nodes as circles
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    }
                    
                    // Reset shadow effects and filters
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.filter = 'none';
                });
            }
            
            drawEdges(edges, nodes) {
                const ctx = this.ctx;
                const baseLineWidth = 3 / this.transform.scale;
                const arrowSize = 12 / this.transform.scale;
                
                // Create node lookup for position data
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                edges.forEach(edge => {
                    const sourceNode = nodeMap[edge.source];
                    const targetNode = nodeMap[edge.target];
                    
                    if (!sourceNode || !targetNode) return;
                    
                    let edgeColor = this.getEdgeColor(edge);
                    let lineWidth = baseLineWidth;
                    
                    // Apply isolation effects
                    const isIsolated = this.isolatedNode !== null;
                    const isConnectedToIsolated = isIsolated && this.isEdgeConnectedToIsolated(edge);
                    
                    if (isIsolated && !isConnectedToIsolated) {
                        // Apply blur and opacity reduction to non-connected edges
                        ctx.filter = 'blur(2px)';
                        edgeColor = edgeColor.replace(/[\d\.]+\)$/, '0.2)'); // Reduce opacity more than nodes
                    } else {
                        ctx.filter = 'none';
                    }
                    
                    // Enhance edges connected to dragged or selected nodes
                    const isSourceDragged = this.draggedNode && this.draggedNode.id === sourceNode.id;
                    const isTargetDragged = this.draggedNode && this.draggedNode.id === targetNode.id;
                    const isSourceSelected = this.selectedNode && this.selectedNode.id === sourceNode.id;
                    const isTargetSelected = this.selectedNode && this.selectedNode.id === targetNode.id;
                    
                    if (isSourceDragged || isTargetDragged) {
                        // Edges connected to dragged nodes: thicker, more prominent
                        lineWidth = baseLineWidth * 1.5;
                        edgeColor = edgeColor.replace(/[\d\.]+\)$/, '0.8)'); // Increase opacity
                    } else if (isSourceSelected || isTargetSelected) {
                        // Edges connected to selected nodes: slightly enhanced
                        lineWidth = baseLineWidth * 1.2;
                        edgeColor = edgeColor.replace(/[\d\.]+\)$/, '0.7)'); // Slightly increase opacity
                    }
                    
                    ctx.strokeStyle = edgeColor;
                    ctx.fillStyle = edgeColor;
                    ctx.lineWidth = lineWidth;
                    
                    // Calculate edge endpoints (accounting for node radius and current visual state)
                    const getNodeRadius = (node) => {
                        const base = this.nodeRadius || 50;
                        if (this.draggedNode && this.draggedNode.id === node.id) return node.anchor ? base * 1.3 : base * 1.1;
                        if (this.selectedNode && this.selectedNode.id === node.id) return node.anchor ? base * 1.25 : base * 1.05;
                        if (this.hoveredNode && this.hoveredNode.id === node.id) return node.anchor ? base * 1.22 : base * 1.02;
                        return node.anchor ? base * 1.2 : base;
                    };
                    const baseNodeRadius = getNodeRadius(sourceNode);
                    function getNodeEdgeIntersection(node, x0, y0, x1, y1) {
                        // Returns the intersection point from (x0, y0) to (x1, y1) with the node's border
                        if (node.anchor) {
                            // Square: calculate intersection with square border
                            const size = 50 * 1.2; // match your square half-size
                            const cx = node.x, cy = node.y;
                            const dx = x1 - x0, dy = y1 - y0;
                            let tMin = Infinity, ix = cx, iy = cy;
                            // Four borders: left, right, top, bottom
                            const borders = [
                                { x: cx - size, y: null }, // left
                                { x: cx + size, y: null }, // right
                                { x: null, y: cy - size }, // top
                                { x: null, y: cy + size }  // bottom
                            ];
                            for (const border of borders) {
                                let t;
                                if (border.x !== null) {
                                    // Vertical border
                                    if (dx !== 0) {
                                        t = (border.x - x0) / dx;
                                        const y = y0 + t * dy;
                                        if (t > 0 && y >= cy - size && y <= cy + size && t < tMin) {
                                            tMin = t;
                                            ix = border.x;
                                            iy = y;
                                        }
                                    }
                                } else {
                                    // Horizontal border
                                    if (dy !== 0) {
                                        t = (border.y - y0) / dy;
                                        const x = x0 + t * dx;
                                        if (t > 0 && x >= cx - size && x <= cx + size && t < tMin) {
                                            tMin = t;
                                            ix = x;
                                            iy = border.y;
                                        }
                                    }
                                }
                            }
                            return { x: ix, y: iy };
                        } else {
                            // Circle: use radius
                            const dx = x1 - x0, dy = y1 - y0;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const r = 50;
                            return {
                                x: node.x + (dx / distance) * r,
                                y: node.y + (dy / distance) * r
                            };
                        }
                    }
                    
                    const start = getNodeEdgeIntersection(sourceNode, sourceNode.x, sourceNode.y, targetNode.x, targetNode.y);
                    const end = getNodeEdgeIntersection(targetNode, targetNode.x, targetNode.y, sourceNode.x, sourceNode.y);

                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    
                    // Draw arrow for directed edges
                    if (edge.directed) {
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const unitX = dx / length;
                        const unitY = dy / length;
                        this.drawArrow(ctx, end.x, end.y, unitX, unitY, arrowSize);
                    }
                    
                    // Reset filter effects
                    ctx.filter = 'none';
                });
            }
            
            drawArrow(ctx, x, y, dirX, dirY, size) {
                // Calculate arrow points
                const arrowAngle = Math.PI / 6; // 30 degrees
                const arrowX1 = x - size * (dirX * Math.cos(arrowAngle) - dirY * Math.sin(arrowAngle));
                const arrowY1 = y - size * (dirY * Math.cos(arrowAngle) + dirX * Math.sin(arrowAngle));
                const arrowX2 = x - size * (dirX * Math.cos(-arrowAngle) - dirY * Math.sin(-arrowAngle));
                const arrowY2 = y - size * (dirY * Math.cos(-arrowAngle) + dirX * Math.sin(-arrowAngle));
                
                // Draw arrow
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(arrowX1, arrowY1);
                ctx.moveTo(x, y);
                ctx.lineTo(arrowX2, arrowY2);
                ctx.stroke();
            }
            
            getNodeColor(node) {
                if (node.anchor) {
                    return 'rgba(239, 68, 68, 0.8)'; // Fixed red color for anchor nodes
                }
                
                // Get or generate color for this node type
                return window.styleManager.getNodeColor(node.label);
            }
            
            getNodeBorderColor(node) {
                return 'rgba(0, 0, 0, 0.3)';
            }
            
            getEdgeColor(edge) {
                // Get or generate color for this edge type
                return window.styleManager.getEdgeColor(edge.label);
            }
            
            drawNodeLabels(nodes) {
                const ctx = this.ctx;
                const fontSize = 14;
                ctx.font = `${fontSize}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const isIsolated = this.isolatedNode !== null;

                nodes.forEach(node => {
                    if (node.label) {
                        // Isolation logic
                        let blur = 0;
                        let bgOpacity = 0.7;
                        let textOpacity = 0.95;
                        let borderOpacity = 0.15;

                        if (isIsolated) {
                            const isIsolatedNode = this.isolatedNode && this.isolatedNode.id === node.id;
                            const isConnectedToIsolated = isIsolated && !isIsolatedNode && this.isNodeConnectedToIsolated(node);

                            if (!isIsolatedNode && !isConnectedToIsolated) {
                                blur = 2;
                                bgOpacity = 0.3;
                                textOpacity = 0.2;
                                borderOpacity = 0.05;
                            }
                        }

                        ctx.save();
                        ctx.filter = blur ? `blur(${blur}px)` : 'none';

                        // Use node.x, node.y directly (world coordinates)
                        const labelX = node.x;
                        const labelY = node.y;

                        let displayLabel = node.display_label || node.label;
                        const lines = displayLabel.split('\n');

                        let maxLineWidth = 0;
                        lines.forEach(line => {
                            const metrics = ctx.measureText(line);
                            if (metrics.width > maxLineWidth) maxLineWidth = metrics.width;
                        });
                        const textHeight = fontSize;
                        const textWidth = maxLineWidth;
                        const padding = 6;
                        const bgWidth = textWidth + (padding * 2);
                        const bgHeight = lines.length * textHeight + (padding * 2);

                        ctx.fillStyle = `rgba(255, 255, 255, ${bgOpacity})`;
                        ctx.strokeStyle = `rgba(0, 0, 0, ${borderOpacity})`;
                        ctx.lineWidth = 1;

                        const cornerRadius = 4;
                        this.drawRoundedRect(
                            ctx,
                            labelX - bgWidth / 2,
                            labelY - bgHeight / 2,
                            bgWidth,
                            bgHeight,
                            cornerRadius
                        );

                        ctx.fillStyle = `rgba(0, 0, 0, ${textOpacity})`;
                        const totalTextHeight = lines.length * textHeight;
                        const startY = labelY - totalTextHeight / 2 + textHeight / 2;
                        lines.forEach((line, i) => {
                            ctx.fillText(line, labelX, startY + i * textHeight);
                        });

                        ctx.restore();
                    }
                });
            }
            
            // Helper method to draw rounded rectangles
            drawRoundedRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawEdgeLabels(edges, nodes) {
                const ctx = this.ctx;
                const fontSize = Math.max(10, 12 / this.transform.scale);
                ctx.font = `${fontSize}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Create node lookup for position data
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                edges.forEach(edge => {
                    if (!edge.label) return;
                    
                    const sourceNode = nodeMap[edge.source];
                    const targetNode = nodeMap[edge.target];
                    
                    if (!sourceNode || !targetNode) return;
                    
                    // Apply isolation effects
                    const isIsolated = this.isolatedNode !== null;
                    const isConnectedToIsolated = isIsolated && this.isEdgeConnectedToIsolated(edge);
                    
                    let bgOpacity = 0.9;
                    let textOpacity = 0.7;
                    let borderOpacity = 0.1;
                    
                    if (isIsolated && !isConnectedToIsolated) {
                        // Apply blur and opacity reduction to non-connected edge labels
                        ctx.filter = 'blur(1px)';
                        bgOpacity = 0.3;
                        textOpacity = 0.2;
                        borderOpacity = 0.05;
                    } else {
                        ctx.filter = 'none';
                    }
                    
                    // Calculate midpoint of edge
                    const midX = (sourceNode.x + targetNode.x) / 2;
                    const midY = (sourceNode.y + targetNode.y) / 2;
                    
                    // Measure text dimensions
                    const textMetrics = ctx.measureText(edge.label);
                    const textWidth = textMetrics.width;
                    const textHeight = fontSize;
                    
                    // Calculate label background dimensions with padding
                    const padding = 2 / this.transform.scale;
                    const bgWidth = textWidth + (padding * 2);
                    const bgHeight = textHeight + (padding * 2);
                    
                    // Draw transparent rectangular background
                    ctx.fillStyle = `rgba(255, 255, 255, ${bgOpacity})`;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${borderOpacity})`;
                    ctx.lineWidth = 0.5 / this.transform.scale;
                    
                    ctx.fillRect(
                        midX - bgWidth / 2,
                        midY - bgHeight / 2,
                        bgWidth,
                        bgHeight
                    );
                    ctx.strokeRect(
                        midX - bgWidth / 2,
                        midY - bgHeight / 2,
                        bgWidth,
                        bgHeight
                    );
                    
                    // Draw text
                    ctx.fillStyle = `rgba(0, 0, 0, ${textOpacity})`;
                    ctx.fillText(edge.label, midX, midY);
                    
                    // Reset filter effects
                    ctx.filter = 'none';
                });
            }
            
            drawGrid() {
                const ctx = this.ctx;
                const baseGridSize = 50; // Base grid spacing in world coordinates
                const lineWidth = Math.max(0.5, 1 / this.transform.scale);
                
                // Calculate visible area in world coordinates
                const topLeft = this.screenToWorld(0, 0);
                const bottomRight = this.screenToWorld(this.canvas.width, this.canvas.height);
                
                // Adaptive grid opacity based on zoom level for better visibility
                const zoomFactor = this.transform.scale;
                const minorOpacity = Math.min(0.05, 0.02 + (zoomFactor * 0.01));
                const majorOpacity = Math.min(0.12, 0.06 + (zoomFactor * 0.02));
                
                // Multi-level grid system for better visual hierarchy
                this.drawGridLevel(ctx, baseGridSize, `rgba(0, 0, 0, ${minorOpacity})`, lineWidth * 0.5, topLeft, bottomRight);
                this.drawGridLevel(ctx, baseGridSize * 5, `rgba(0, 0, 0, ${majorOpacity})`, lineWidth * 1.5, topLeft, bottomRight);
                
                // Draw origin axes with stronger lines and subtle gradient effect
                this.drawOriginAxes(ctx, lineWidth, topLeft, bottomRight);
                
                // Add subtle dot pattern at grid intersections for major grid
                this.drawGridDots(ctx, baseGridSize * 5, lineWidth, topLeft, bottomRight);
            }
            
            drawGridLevel(ctx, gridSize, strokeStyle, lineWidth, topLeft, bottomRight) {
                // Calculate grid bounds
                const startX = Math.floor(topLeft.x / gridSize) * gridSize;
                const endX = Math.ceil(bottomRight.x / gridSize) * gridSize;
                const startY = Math.floor(topLeft.y / gridSize) * gridSize;
                const endY = Math.ceil(bottomRight.y / gridSize) * gridSize;
                
                // Set grid style
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.setLineDash([]);
                
                // Draw vertical lines
                for (let x = startX; x <= endX; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                    ctx.stroke();
                }
                
                // Draw horizontal lines
                for (let y = startY; y <= endY; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                    ctx.stroke();
                }
            }
            
            drawOriginAxes(ctx, lineWidth, topLeft, bottomRight) {
                const startX = topLeft.x;
                const endX = bottomRight.x;
                const startY = topLeft.y;
                const endY = bottomRight.y;
                
                // Enhanced origin axes with gradient-like effect
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.15)';
                ctx.lineWidth = lineWidth * 3;
                
                // X-axis
                if (startY <= 0 && endY >= 0) {
                    ctx.beginPath();
                    ctx.moveTo(startX, 0);
                    ctx.lineTo(endX, 0);
                    ctx.stroke();
                }
                
                // Y-axis
                if (startX <= 0 && endX >= 0) {
                    ctx.beginPath();
                    ctx.moveTo(0, startY);
                    ctx.lineTo(0, endY);
                    ctx.stroke();
                }
                
                // Add subtle center point indicator
                if (startX <= 0 && endX >= 0 && startY <= 0 && endY >= 0) {
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 4 / this.transform.scale, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            drawGridDots(ctx, gridSize, lineWidth, topLeft, bottomRight) {
                // Only draw dots when zoomed in enough to see them clearly
                if (this.transform.scale < 0.5) return;
                
                const startX = Math.floor(topLeft.x / gridSize) * gridSize;
                const endX = Math.ceil(bottomRight.x / gridSize) * gridSize;
                const startY = Math.floor(topLeft.y / gridSize) * gridSize;
                const endY = Math.ceil(bottomRight.y / gridSize) * gridSize;
                
                const dotRadius = Math.max(0.5, 1.5 / this.transform.scale);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                
                // Draw dots at major grid intersections
                for (let x = startX; x <= endX; x += gridSize) {
                    for (let y = startY; y <= endY; y += gridSize) {
                        // Skip origin point (already drawn)
                        if (x === 0 && y === 0) continue;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, dotRadius, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            }
            
            // Utility method to convert screen coordinates to world coordinates
            screenToWorld(screenX, screenY) {
                return {
                    x: (screenX - this.transform.x) / this.transform.scale,
                    y: (screenY - this.transform.y) / this.transform.scale
                };
            }
            
            // Utility method to convert world coordinates to screen coordinates
            worldToScreen(worldX, worldY) {
                return {
                    x: worldX * this.transform.scale + this.transform.x,
                    y: worldY * this.transform.scale + this.transform.y
                };
            }
            
            // Node interaction methods
            getNodeAtPosition(worldX, worldY) {
                // Get nodes from current graph data or test data
                let nodes = [];
                if (GRAPH_DATA && GRAPH_DATA.nodes && GRAPH_DATA.nodes.length > 0) {
                    nodes = GRAPH_DATA.nodes;
                } else {
                    // Use test nodes if no graph data available
                    nodes = [
                        {
                            id: 'origin', 
                            x: 0, y: 0, 
                            type: 'anchor', 
                            label: 'Origin', 
                            anchor: true
                        },
                        {
                            id: 'processor', 
                            x: 120, y: 60, 
                            type: 'computation', 
                            label: 'Processor', 
                            anchor: false
                        },
                        {
                            id: 'database', 
                            x: -90, y: 140, 
                            type: 'storage', 
                            label: 'Database', 
                            anchor: false
                        },
                        {
                            id: 'api', 
                            x: 180, y: -120, 
                            type: 'service', 
                            label: 'API Gateway', 
                            anchor: false
                        },
                        {
                            id: 'cache', 
                            x: -140, y: -90, 
                            type: 'storage', 
                            label: 'Cache', 
                            anchor: false
                        },
                        {
                            id: 'monitor', 
                            x: 60, y: -180, 
                            type: 'analytics', 
                            label: 'Monitor', 
                            anchor: false
                        },
                        {
                            id: 'queue', 
                            x: -60, y: 180, 
                            type: 'messaging', 
                            label: 'Message Queue', 
                            anchor: false
                        },
                        {
                            id: 'auth', 
                            x: 200, y: 80, 
                            type: 'security', 
                            label: 'Auth Service', 
                            anchor: false
                        }
                    ];
                }
                
                // Check nodes in reverse z-order (top to bottom) for proper layering
                const orderedNodes = this.getNodesInZOrder(nodes);
                
                const fontSize = Math.max(10, 12 / this.transform.scale);
                const padding = 3 / this.transform.scale;

                for (let i = orderedNodes.length - 1; i >= 0; i--) {
                    const node = orderedNodes[i];
                    let displayLabel = node.display_label || node.label;
                    const lines = displayLabel.split('\n');
                    this.ctx.font = `${fontSize}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;
                    let maxLineWidth = 0;
                    lines.forEach(line => {
                        const metrics = this.ctx.measureText(line);
                        if (metrics.width > maxLineWidth) maxLineWidth = metrics.width;
                    });
                    const textHeight = fontSize;
                    const bgWidth = maxLineWidth + (padding * 2);
                    const bgHeight = lines.length * textHeight + (padding * 2);
                    const labelX = node.x;
                    const labelY = node.y;
                    const labelLeft = labelX - bgWidth / 2;
                    const labelRight = labelX + bgWidth / 2;
                    const labelTop = labelY - bgHeight / 2;
                    const labelBottom = labelY + bgHeight / 2;

                    if (
                        worldX >= labelLeft &&
                        worldX <= labelRight &&
                        worldY >= labelTop &&
                        worldY <= labelBottom
                    ) {
                        return node;
                    }

                    const distance = Math.sqrt(
                        Math.pow(worldX - node.x, 2) + Math.pow(worldY - node.y, 2)
                    );
                    const hitRadius = node.anchor ? this.hoverRadius * 1.2 : this.hoverRadius;

                    if (distance <= hitRadius) {
                        return node;
                    }
                }

                return null;
            }
            
            getNodesInZOrder(nodes) {
                // If we have a z-order array, use it to sort nodes
                if (this.nodeZOrder.length > 0) {
                    const zOrderMap = {};
                    this.nodeZOrder.forEach((nodeId, index) => {
                        zOrderMap[nodeId] = index;
                    });
                    
                    return [...nodes].sort((a, b) => {
                        const aOrder = zOrderMap[a.id] !== undefined ? zOrderMap[a.id] : -1;
                        const bOrder = zOrderMap[b.id] !== undefined ? zOrderMap[b.id] : -1;
                        return aOrder - bOrder;
                    });
                } else {
                    // Initialize z-order with current node order
                    this.nodeZOrder = nodes.map(node => node.id);
                    return [...nodes];
                }
            }
            
            bringNodeToFront(node) {
                // Remove node from current position in z-order
                const nodeIndex = this.nodeZOrder.indexOf(node.id);
                if (nodeIndex > -1) {
                    this.nodeZOrder.splice(nodeIndex, 1);
                }
                
                // Add node to the end (front) of z-order
                this.nodeZOrder.push(node.id);
                
                // Ensure z-order doesn't grow indefinitely
                if (this.nodeZOrder.length > 100) {
                    this.nodeZOrder = this.nodeZOrder.slice(-50);
                }
            }
        }

        // Export System
        class ExportManager {
            constructor(canvas) {
                this.canvas = canvas;
            }
            generateGraphSVGString(width, height) {
                const svgns = "http://www.w3.org/2000/svg";
                const svgElem = document.createElementNS(svgns, "svg");
                svgElem.setAttribute("width", width);
                svgElem.setAttribute("height", height);
                svgElem.setAttribute("xmlns", svgns);
                svgElem.setAttribute("style", "background: #fafafa");

                // --- Draw grid pattern (20x20 dots) ---
                for (let x = 0; x < width; x += 20) {
                    for (let y = 0; y < height; y += 20) {
                        const dot = document.createElementNS(svgns, "circle");
                        dot.setAttribute("cx", x + 1);
                        dot.setAttribute("cy", y + 1);
                        dot.setAttribute("r", 1);
                        dot.setAttribute("fill", "rgba(0,0,0,0.02)");
                        svgElem.appendChild(dot);
                    }
                }

                // --- Draw edges ---
                const nodeMap = {};
                GRAPH_DATA.nodes.forEach(node => nodeMap[node.id] = node);

                GRAPH_DATA.edges.forEach(edge => {
                    const source = nodeMap[edge.source];
                    const target = nodeMap[edge.target];
                    if (!source || !target) return;
                    const line = document.createElementNS(svgns, "line");
                    line.setAttribute("x1", source.x);
                    line.setAttribute("y1", source.y);
                    line.setAttribute("x2", target.x);
                    line.setAttribute("y2", target.y);
                    line.setAttribute("stroke", window.styleManager.getEdgeColor(edge.label));
                    line.setAttribute("stroke-width", 3);
                    svgElem.appendChild(line);

                    // Edge label (midpoint)
                    if (edge.label) {
                        const midX = (source.x + target.x) / 2;
                        const midY = (source.y + target.y) / 2;
                        const text = document.createElementNS(svgns, "text");
                        text.setAttribute("x", midX);
                        text.setAttribute("y", midY - 6);
                        text.setAttribute("font-size", "12");
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("fill", "#333");
                        text.textContent = edge.label;
                        svgElem.appendChild(text);
                    }
                });

                // --- Draw nodes ---
                GRAPH_DATA.nodes.forEach(node => {
                    if (node.anchor) {
                        // Anchor as square
                        const rect = document.createElementNS(svgns, "rect");
                        rect.setAttribute("x", node.x - 60);
                        rect.setAttribute("y", node.y - 60);
                        rect.setAttribute("width", 120);
                        rect.setAttribute("height", 120);
                        rect.setAttribute("fill", "rgba(239, 68, 68, 0.8)");
                        rect.setAttribute("stroke", "rgba(0,0,0,0.3)");
                        rect.setAttribute("stroke-width", 3);
                        svgElem.appendChild(rect);
                    } else {
                        // Regular node as circle
                        const circle = document.createElementNS(svgns, "circle");
                        circle.setAttribute("cx", node.x);
                        circle.setAttribute("cy", node.y);
                        circle.setAttribute("r", 50);
                        circle.setAttribute("fill", window.styleManager.getNodeColor(node.label));
                        circle.setAttribute("stroke", "rgba(0,0,0,0.3)");
                        circle.setAttribute("stroke-width", 3);
                        svgElem.appendChild(circle);
                    }

                    // Node label (multi-line)
                    let label = node.display_label || node.label;
                    const lines = label.split('\n');
                    lines.forEach((line, i) => {
                        const text = document.createElementNS(svgns, "text");
                        text.setAttribute("x", node.x);
                        text.setAttribute("y", node.y + (i - (lines.length-1)/2) * 16);
                        text.setAttribute("font-size", "14");
                        text.setAttribute("text-anchor", "middle");
                        text.setAttribute("fill", "#222");
                        text.textContent = line;
                        svgElem.appendChild(text);
                    });
                });

                // --- Draw legend (bottom right) ---
                const nodeTypes = (GRAPH_DATA.legend && GRAPH_DATA.legend.nodeTypes) || [];
                const edgeTypes = (GRAPH_DATA.legend && GRAPH_DATA.legend.edgeTypes) || [];
                const legendWidth = 240, legendHeight = 80 + 28 * nodeTypes.length + 24 * edgeTypes.length + 60;
                const legendX = width - legendWidth - 32, legendY = height - legendHeight - 32;

                const legendBg = document.createElementNS(svgns, "rect");
                legendBg.setAttribute("x", legendX);
                legendBg.setAttribute("y", legendY);
                legendBg.setAttribute("width", legendWidth);
                legendBg.setAttribute("height", legendHeight);
                legendBg.setAttribute("rx", 14);
                legendBg.setAttribute("fill", "white");
                legendBg.setAttribute("stroke", "rgba(0,0,0,0.12)");
                legendBg.setAttribute("stroke-width", 2);
                svgElem.appendChild(legendBg);

                let legendYPos = legendY + 28;
                // Title
                const legendTitle = document.createElementNS(svgns, "text");
                legendTitle.setAttribute("x", legendX + 16);
                legendTitle.setAttribute("y", legendYPos);
                legendTitle.setAttribute("font-size", "16");
                legendTitle.setAttribute("font-weight", "bold");
                legendTitle.setAttribute("fill", "#222");
                legendTitle.textContent = "Legend";
                svgElem.appendChild(legendTitle);
                legendYPos += 28;

                // Node Types
                if (nodeTypes.length > 0) {
                    const nodeTypeHeader = document.createElementNS(svgns, "text");
                    nodeTypeHeader.setAttribute("x", legendX + 16);
                    nodeTypeHeader.setAttribute("y", legendYPos);
                    nodeTypeHeader.setAttribute("font-size", "13");
                    nodeTypeHeader.setAttribute("fill", "#666");
                    nodeTypeHeader.textContent = "Node Types";
                    svgElem.appendChild(nodeTypeHeader);
                    legendYPos += 20;

                    nodeTypes.forEach(nt => {
                        const box = document.createElementNS(svgns, "rect");
                        box.setAttribute("x", legendX + 16);
                        box.setAttribute("y", legendYPos - 10);
                        box.setAttribute("width", 18);
                        box.setAttribute("height", 18);
                        box.setAttribute("rx", 4);
                        box.setAttribute("fill", nt.color);
                        box.setAttribute("stroke", "#bbb");
                        box.setAttribute("stroke-width", 1);
                        svgElem.appendChild(box);

                        const label = document.createElementNS(svgns, "text");
                        label.setAttribute("x", legendX + 44);
                        label.setAttribute("y", legendYPos + 4);
                        label.setAttribute("font-size", "13");
                        label.setAttribute("fill", "#222");
                        label.textContent = nt.label;
                        svgElem.appendChild(label);

                        legendYPos += 28;
                    });
                }

                // Edge Types
                if (edgeTypes.length > 0) {
                    const edgeTypeHeader = document.createElementNS(svgns, "text");
                    edgeTypeHeader.setAttribute("x", legendX + 16);
                    edgeTypeHeader.setAttribute("y", legendYPos);
                    edgeTypeHeader.setAttribute("font-size", "13");
                    edgeTypeHeader.setAttribute("fill", "#666");
                    edgeTypeHeader.textContent = "Edge Types";
                    svgElem.appendChild(edgeTypeHeader);
                    legendYPos += 20;

                    edgeTypes.forEach(et => {
                        const line = document.createElementNS(svgns, "rect");
                        line.setAttribute("x", legendX + 16);
                        line.setAttribute("y", legendYPos - 3);
                        line.setAttribute("width", 18);
                        line.setAttribute("height", 6);
                        line.setAttribute("rx", 2);
                        line.setAttribute("fill", et.color);
                        line.setAttribute("stroke", "#bbb");
                        line.setAttribute("stroke-width", 1);
                        svgElem.appendChild(line);

                        const label = document.createElementNS(svgns, "text");
                        label.setAttribute("x", legendX + 44);
                        label.setAttribute("y", legendYPos + 4);
                        label.setAttribute("font-size", "13");
                        label.setAttribute("fill", "#222");
                        label.textContent = et.label;
                        svgElem.appendChild(label);

                        legendYPos += 24;
                    });
                }

                // Anchor Nodes
                const anchorHeader = document.createElementNS(svgns, "text");
                anchorHeader.setAttribute("x", legendX + 16);
                anchorHeader.setAttribute("y", legendYPos);
                anchorHeader.setAttribute("font-size", "13");
                anchorHeader.setAttribute("fill", "#666");
                anchorHeader.textContent = "Special Nodes";
                svgElem.appendChild(anchorHeader);
                legendYPos += 20;

                const anchorBox = document.createElementNS(svgns, "rect");
                anchorBox.setAttribute("x", legendX + 16);
                anchorBox.setAttribute("y", legendYPos - 10);
                anchorBox.setAttribute("width", 18);
                anchorBox.setAttribute("height", 18);
                anchorBox.setAttribute("rx", 2);
                anchorBox.setAttribute("fill", "rgba(239, 68, 68, 0.8)");
                anchorBox.setAttribute("stroke", "#bbb");
                anchorBox.setAttribute("stroke-width", 1);
                svgElem.appendChild(anchorBox);

                const anchorLabel = document.createElementNS(svgns, "text");
                anchorLabel.setAttribute("x", legendX + 44);
                anchorLabel.setAttribute("y", legendYPos + 4);
                anchorLabel.setAttribute("font-size", "13");
                anchorLabel.setAttribute("fill", "#222");
                anchorLabel.textContent = "Anchor Nodes";
                svgElem.appendChild(anchorLabel);

                // --- Serialize to string ---
                const serializer = new XMLSerializer();
                return serializer.serializeToString(svgElem);
            }

            async exportToPDF() {
                const { PDFDocument, rgb, degrees, StandardFonts } = window.PDFLib;
                const width = this.canvas.width;
                const height = this.canvas.height;

                // Create a new PDF document and page
                const pdfDoc = await PDFDocument.create();
                const page = pdfDoc.addPage([width, height]);
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);

                // Draw grid pattern (20x20 dots)
                for (let x = 0; x < width; x += 20) {
                    for (let y = 0; y < height; y += 20) {
                        page.drawCircle({
                            x: x + 1,
                            y: height - (y + 1),
                            size: 1,
                            color: rgb(0, 0, 0),
                            opacity: 0.02,
                            borderWidth: 0,
                        });
                    }
                }

                // Draw edges
                const nodeMap = {};
                GRAPH_DATA.nodes.forEach(node => nodeMap[node.id] = node);

                GRAPH_DATA.edges.forEach(edge => {
                    const source = nodeMap[edge.source];
                    const target = nodeMap[edge.target];
                    if (!source || !target) return;
                    const [r, g, b, a] = parseRgba(window.styleManager.getEdgeColor(edge.label));
                    page.drawLine({
                        start: { x: source.x, y: height - source.y },
                        end: { x: target.x, y: height - target.y },
                        thickness: 3,
                        color: rgb(r, g, b),
                        opacity: a,
                    });

                    // Edge label (midpoint, with white bg)
                    if (edge.label) {
                        const midX = (source.x + target.x) / 2;
                        const midY = (source.y + target.y) / 2;
                        const fontSize = 12;
                        const padding = 4;
                        const textWidth = font.widthOfTextAtSize(edge.label, fontSize);
                        const textHeight = fontSize;
                        const bgWidth = textWidth + padding * 2;
                        const bgHeight = textHeight + padding * 2;
                        // Draw white background
                        page.drawRectangle({
                            x: midX - bgWidth / 2,
                            y: height - midY - bgHeight / 2,
                            width: bgWidth,
                            height: bgHeight,
                            color: rgb(1, 1, 1),
                            opacity: 0.95,
                            borderWidth: 0,
                        });
                        // Draw text
                        page.drawText(edge.label, {
                            x: midX - textWidth / 2,
                            y: height - midY - bgHeight / 2 + padding,
                            size: fontSize,
                            font,
                            color: rgb(0.2, 0.2, 0.2),
                        });
                    }
                });

                // Draw nodes
                GRAPH_DATA.nodes.forEach(node => {
                    if (node.anchor) {
                        // Anchor as square
                        page.drawRectangle({
                            x: node.x - 60,
                            y: height - (node.y + 60),
                            width: 120,
                            height: 120,
                            color: rgb(239/255, 68/255, 68/255),
                            opacity: 0.8,
                            borderColor: rgb(0, 0, 0),
                            borderWidth: 3,
                        });
                    } else {
                        // Regular node as circle
                        const [r, g, b, a] = parseRgba(window.styleManager.getNodeColor(node.label));
                        page.drawCircle({
                            x: node.x,
                            y: height - node.y,
                            size: 50,
                            color: rgb(r, g, b),
                            opacity: a,
                            borderColor: rgb(0, 0, 0),
                            borderWidth: 3,
                        });
                    }

                    // Node label (multi-line, with white rounded rect background)
                    let label = node.display_label || node.label;
                    const lines = label.split('\n');
                    const fontSize = 14;
                    const padding = 6;
                    let maxLineWidth = 0;
                    lines.forEach(line => {
                        const width = font.widthOfTextAtSize(line, fontSize);
                        if (width > maxLineWidth) maxLineWidth = width;
                    });
                    const bgWidth = maxLineWidth + padding * 2;
                    const bgHeight = lines.length * fontSize + padding * 2;
                    const rectX = node.x - bgWidth / 2;
                    const rectY = height - node.y - bgHeight / 2;

                    // Draw white rounded rectangle background (no border)
                    drawRoundedRect(page, rectX, rectY, bgWidth, bgHeight, 6, rgb(1, 1, 1), 0.95);

                    // Draw each line of label (centered)
                    lines.forEach((line, i) => {
                        page.drawText(line, {
                            x: node.x - font.widthOfTextAtSize(line, fontSize) / 2,
                            y: height - (node.y + (i - (lines.length - 1) / 2) * fontSize) - fontSize / 2,
                            size: fontSize,
                            font,
                            color: rgb(0.13, 0.13, 0.13),
                        });
                    });
                });

                // Draw legend (bottom right)
                const nodeTypes = (GRAPH_DATA.legend && GRAPH_DATA.legend.nodeTypes) || [];
                const edgeTypes = (GRAPH_DATA.legend && GRAPH_DATA.legend.edgeTypes) || [];
                const legendWidth = 240, legendHeight = 80 + 28 * nodeTypes.length + 24 * edgeTypes.length + 60;
                const legendX = width - legendWidth - 32, legendY = height - legendHeight - 32;

                // Legend background
                page.drawRectangle({
                    x: legendX,
                    y: legendY,
                    width: legendWidth,
                    height: legendHeight,
                    color: rgb(1, 1, 1),
                    opacity: 0.97,
                    borderColor: rgb(0, 0, 0),
                    borderWidth: 2,
                });

                let legendYPos = legendY + legendHeight - 28;
                // Title
                page.drawText("Legend", {
                    x: legendX + 16,
                    y: legendYPos,
                    size: 16,
                    font,
                    color: rgb(0.13, 0.13, 0.13),
                });
                legendYPos -= 28;
                // Node Types
                if (nodeTypes.length > 0) {
                    page.drawText("Node Types", {
                        x: legendX + 16,
                        y: legendYPos,
                        size: 13,
                        font,
                        color: rgb(0.4, 0.4, 0.4),
                    });
                    legendYPos -= 20;

                    nodeTypes.forEach(nt => {
                        const [r, g, b, a] = parseRgba(nt.color);
                        // Color box
                        const boxY = legendYPos - 10;
                        page.drawRectangle({
                            x: legendX + 16,
                            y: boxY,
                            width: 18,
                            height: 18,
                            color: rgb(r, g, b),
                            opacity: a,
                            borderColor: rgb(0.73, 0.73, 0.73),
                            borderWidth: 1,
                        });
                        // Vertically center text with box
                        page.drawText(nt.label, {
                            x: legendX + 44,
                            y: boxY + 9 - 6, // 9 is half of 18, -6 to visually center with font size 13
                            size: 13,
                            font,
                            color: rgb(0.13, 0.13, 0.13),
                        });
                        legendYPos -= 28;
                    });
                }

                // Edge Types
                if (edgeTypes.length > 0) {
                    page.drawText("Edge Types", {
                        x: legendX + 16,
                        y: legendYPos,
                        size: 13,
                        font,
                        color: rgb(0.4, 0.4, 0.4),
                    });
                    legendYPos -= 20;

                    edgeTypes.forEach(et => {
                        const [r, g, b, a] = parseRgba(et.color);
                        // Color line (rectangle)
                        const lineY = legendYPos + 9 - 3; // 9 is half of 18, -3 to center 6px line
                        page.drawRectangle({
                            x: legendX + 16,
                            y: lineY,
                            width: 18,
                            height: 6,
                            color: rgb(r, g, b),
                            opacity: a,
                            borderColor: rgb(0.73, 0.73, 0.73),
                            borderWidth: 1,
                        });
                        // Vertically center text with line
                        page.drawText(et.label, {
                            x: legendX + 44,
                            y: lineY + 3 - 6, // 3 is half of 6, -6 to visually center with font size 13
                            size: 13,
                            font,
                            color: rgb(0.13, 0.13, 0.13),
                        });
                        legendYPos -= 24;
                    });
                }

                // Anchor Nodes
                page.drawText("Special Nodes", {
                    x: legendX + 16,
                    y: legendYPos,
                    size: 13,
                    font,
                    color: rgb(0.4, 0.4, 0.4),
                });
                legendYPos -= 20;

                const anchorBoxY = legendYPos - 10;
                page.drawRectangle({
                    x: legendX + 16,
                    y: anchorBoxY,
                    width: 18,
                    height: 18,
                    color: rgb(239/255, 68/255, 68/255),
                    opacity: 0.8,
                    borderColor: rgb(0.73, 0.73, 0.73),
                    borderWidth: 1,
                });
                page.drawText("Anchor Nodes", {
                    x: legendX + 44,
                    y: anchorBoxY + 9 - 6,
                    size: 13,
                    font,
                    color: rgb(0.13, 0.13, 0.13),
                });

                // Save and download
                const pdfBytes = await pdfDoc.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `graph_visualization_${new Date().getTime()}.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                // --- Helper: parse rgba/hex color to [r,g,b,a] in 0-1 range ---
                function parseRgba(color) {
                    if (!color) return [0, 0, 0, 1];
                    if (color.startsWith('rgba')) {
                        const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*([\d\.]+)?\)/);
                        if (!match) return [0, 0, 0, 1];
                        return [
                            parseInt(match[1]) / 255,
                            parseInt(match[2]) / 255,
                            parseInt(match[3]) / 255,
                            match[4] !== undefined ? parseFloat(match[4]) : 1
                        ];
                    } else if (color.startsWith('rgb')) {
                        const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                        if (!match) return [0, 0, 0, 1];
                        return [
                            parseInt(match[1]) / 255,
                            parseInt(match[2]) / 255,
                            parseInt(match[3]) / 255,
                            1
                        ];
                    } else if (color.startsWith('#')) {
                        let hex = color.replace('#', '');
                        if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
                        const num = parseInt(hex, 16);
                        return [
                            ((num >> 16) & 255) / 255,
                            ((num >> 8) & 255) / 255,
                            (num & 255) / 255,
                            1
                        ];
                    }
                    return [0, 0, 0, 1];
                }

                // --- Helper: draw rounded rectangle (pdf-lib doesn't have built-in) ---
                function drawRoundedRect(page, x, y, width, height, radius, fillColor, fillAlpha = 1) {
                    page.drawRectangle({
                        x, y, width, height,
                        borderWidth: 0,
                        color: fillColor,
                        opacity: fillAlpha,
                    });
                }
            }

            exportHighQualityPNG(scale = 1) {
                const origCanvas = this.canvas;
                const width = origCanvas.width;
                const height = origCanvas.height;

                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = width * scale;
                exportCanvas.height = height * scale;
                const exportCtx = exportCanvas.getContext('2d');

                exportCtx.setTransform(scale, 0, 0, scale, 0, 0);

                const oldCanvas = window.canvasNavigator.canvas;
                const oldCtx = window.canvasNavigator.ctx;
                window.canvasNavigator.canvas = exportCanvas;
                window.canvasNavigator.ctx = exportCtx;

                window.canvasNavigator.render();

                exportCtx.globalCompositeOperation = 'destination-over';

                exportCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-primary') || '#fafafa';
                exportCtx.fillRect(0, 0, width, height);

                exportCtx.fillStyle = 'rgba(0,0,0,0.02)';
                for (let x = 0; x < width; x += 20) {
                    for (let y = 0; y < height; y += 20) {
                        exportCtx.beginPath();
                        exportCtx.arc(x + 1, y + 1, 1, 0, 2 * Math.PI);
                        exportCtx.fill();
                    }
                }


                exportCtx.globalCompositeOperation = 'source-over';

                if (window.exportManager && window.exportManager.drawLegendOnCanvas) {
                    window.exportManager.drawLegendOnCanvas(exportCtx, scale);
                }

                window.canvasNavigator.canvas = oldCanvas;
                window.canvasNavigator.ctx = oldCtx;

                // Export as PNG
                exportCanvas.toBlob(blob => {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `graph_visualization_${new Date().getTime()}_hq.png`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                }, 'image/png');
            }

            drawLegendOnCanvas(ctx = this.canvas.getContext('2d'), scale = 1) {
                // Legend dimensions and position (bottom right)
                const canvasWidth = this.canvas.width * scale;
                const canvasHeight = this.canvas.height * scale;
                const legendWidth = 240 * scale;
                const nodeTypes = (GRAPH_DATA.legend && GRAPH_DATA.legend.nodeTypes) || [];
                const edgeTypes = (GRAPH_DATA.legend && GRAPH_DATA.legend.edgeTypes) || [];
                const nodeCount = nodeTypes.length;
                const edgeCount = edgeTypes.length;
                const legendHeight = (80 + 28 * nodeCount + 24 * edgeCount + 60) * scale;
                const padding = 16 * scale;
                const x = canvasWidth - legendWidth - 32 * scale;
                const y = canvasHeight - legendHeight - 32 * scale;

                // Draw background
                ctx.save();
                ctx.resetTransform && ctx.resetTransform();
                ctx.beginPath();
                const radius = 14 * scale;
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + legendWidth - radius, y);
                ctx.quadraticCurveTo(x + legendWidth, y, x + legendWidth, y + radius);
                ctx.lineTo(x + legendWidth, y + legendHeight - radius);
                ctx.quadraticCurveTo(x + legendWidth, y + legendHeight, x + legendWidth - radius, y + legendHeight);
                ctx.lineTo(x + radius, y + legendHeight);
                ctx.quadraticCurveTo(x, y + legendHeight, x, y + legendHeight - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fillStyle = 'rgba(255,255,255,0.97)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.12)';
                ctx.lineWidth = 2 * scale;
                ctx.stroke();

                // Draw "Legend" title
                ctx.fillStyle = '#222';
                ctx.font = `${16 * scale}px sans-serif`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText('Legend', x + padding, y + padding);

                let currentY = y + padding + 24 * scale;

                // Node Types
                if (nodeCount > 0) {
                    ctx.font = `${13 * scale}px sans-serif`;
                    ctx.fillStyle = '#666';
                    ctx.textBaseline = 'top';
                    ctx.fillText('Node Types', x + padding, currentY);
                    currentY += 20 * scale;
                    nodeTypes.forEach(nt => {
                        // Color box
                        const boxY = currentY;
                        ctx.fillStyle = nt.color;
                        ctx.strokeStyle = '#bbb';
                        ctx.lineWidth = 1 * scale;
                        ctx.beginPath();
                        ctx.roundRect(x + padding, boxY, 18 * scale, 18 * scale, 4 * scale);
                        ctx.fill();
                        ctx.stroke();
                        // Label
                        ctx.fillStyle = '#222';
                        ctx.font = `${13 * scale}px sans-serif`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(nt.label, x + padding + 28 * scale, boxY + 9 * scale);
                        currentY += 28 * scale;
                    });
                }

                // Edge Types
                if (edgeCount > 0) {
                    ctx.font = `${13 * scale}px sans-serif`;
                    ctx.fillStyle = '#666';
                    ctx.textBaseline = 'top';
                    ctx.fillText('Edge Types', x + padding, currentY);
                    currentY += 20 * scale;
                    edgeTypes.forEach(et => {
                        // Color line
                        const lineY = currentY + 9 * scale;
                        ctx.strokeStyle = et.color;
                        ctx.lineWidth = 6 * scale;
                        ctx.beginPath();
                        ctx.moveTo(x + padding, lineY);
                        ctx.lineTo(x + padding + 18 * scale, lineY);
                        ctx.stroke();
                        // Label
                        ctx.fillStyle = '#222';
                        ctx.font = `${13 * scale}px sans-serif`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(et.label, x + padding + 28 * scale, lineY);
                        currentY += 24 * scale;
                    });
                }

                // Anchor Nodes
                ctx.font = `${13 * scale}px sans-serif`;
                ctx.fillStyle = '#666';
                ctx.textBaseline = 'top';
                ctx.fillText('Special Nodes', x + padding, currentY);
                currentY += 20 * scale;
                // Red square for anchor
                const anchorBoxY = currentY;
                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                ctx.strokeStyle = '#bbb';
                ctx.lineWidth = 1 * scale;
                ctx.beginPath();
                ctx.rect(x + padding, anchorBoxY, 18 * scale, 18 * scale);
                ctx.fill();
                ctx.stroke();
                // Label
                ctx.fillStyle = '#222';
                ctx.font = `${13 * scale}px sans-serif`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('Anchor Nodes', x + padding + 28 * scale, anchorBoxY + 9 * scale);

                ctx.restore();
            }
        }

        // UI Management System
        class UIManager {
            constructor() {
                this.setupLegend();
                this.setupControls();
            }
            
            setupLegend() {
                const legendContent = document.getElementById('legend-content');
                
                // Check if we have predefined legend data
                if (GRAPH_DATA.legend && (GRAPH_DATA.legend.nodeTypes.length > 0 || GRAPH_DATA.legend.edgeTypes.length > 0)) {
                    // Use predefined legend data and populate StyleManager with those colors
                    this.setupPredefinedLegend(legendContent);
                } else {
                    // Initialize with placeholder - will be populated by StyleManager.discoverTypes()
                    legendContent.innerHTML = `
                        <div class="legend-section">
                            <h4>Legend</h4>
                            <div class="legend-item">
                                <span>Analyzing graph types...</span>
                            </div>
                        </div>
                    `;
                }
            }
            
            setupPredefinedLegend(legendContent) {
                legendContent.innerHTML = '';
                
                // Node types section
                if (GRAPH_DATA.legend.nodeTypes.length > 0) {
                    const nodeSection = document.createElement('div');
                    nodeSection.className = 'legend-section';
                    
                    const header = document.createElement('h4');
                    header.textContent = 'Node Types';
                    nodeSection.appendChild(header);
                    
                    GRAPH_DATA.legend.nodeTypes.forEach(nodeType => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        
                        const colorBox = document.createElement('div');
                        colorBox.className = 'legend-color';
                        colorBox.style.backgroundColor = nodeType.color;
                        
                        const label = document.createElement('span');
                        label.textContent = nodeType.label;
                        
                        item.appendChild(colorBox);
                        item.appendChild(label);
                        nodeSection.appendChild(item);
                        
                        // Populate StyleManager with predefined colors
                        if (window.styleManager) {
                            window.styleManager.nodeTypeColors.set(nodeType.label, nodeType.color);
                            window.styleManager.discoveredNodeTypes.add(nodeType.label);
                        }
                    });
                    
                    legendContent.appendChild(nodeSection);
                }
                
                // Edge types section
                if (GRAPH_DATA.legend.edgeTypes.length > 0) {
                    const edgeSection = document.createElement('div');
                    edgeSection.className = 'legend-section';
                    
                    const header = document.createElement('h4');
                    header.textContent = 'Edge Types';
                    edgeSection.appendChild(header);
                    
                    GRAPH_DATA.legend.edgeTypes.forEach(edgeType => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        
                        const colorBox = document.createElement('div');
                        colorBox.className = 'legend-color';
                        colorBox.style.backgroundColor = edgeType.color;
                        
                        const label = document.createElement('span');
                        label.textContent = edgeType.label;
                        
                        item.appendChild(colorBox);
                        item.appendChild(label);
                        edgeSection.appendChild(item);
                        
                        // Populate StyleManager with predefined colors
                        if (window.styleManager) {
                            window.styleManager.edgeTypeColors.set(edgeType.label, edgeType.color);
                            window.styleManager.discoveredEdgeTypes.add(edgeType.label);
                        }
                    });
                    
                    legendContent.appendChild(edgeSection);
                }
                
                // Always add anchor nodes section
                const anchorSection = document.createElement('div');
                anchorSection.className = 'legend-section';
                
                const header = document.createElement('h4');
                header.textContent = 'Special Nodes';
                anchorSection.appendChild(header);
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-shape';
                colorBox.style.backgroundColor = 'rgba(239, 68, 68, 0.8)';
                colorBox.style.borderRadius = '2px';
                
                const label = document.createElement('span');
                label.textContent = 'Anchor Nodes';
                
                item.appendChild(colorBox);
                item.appendChild(label);
                anchorSection.appendChild(item);
                
                legendContent.appendChild(anchorSection);
            }
            
            setupControls() {
                // Initialize labels as enabled by default
                window.labelsEnabled = true;
                
                // Label toggle functionality
                const labelToggle = document.getElementById('label-toggle');
                labelToggle.addEventListener('change', function() {
                    window.labelsEnabled = this.checked;
                    // Trigger re-render to show/hide labels
                    if (window.canvasNavigator) {
                        window.canvasNavigator.render();
                    }
                    console.log('Labels', this.checked ? 'enabled' : 'disabled');
                });
                
                // Initialize export manager
                const canvas = document.getElementById('graph-canvas');
                window.exportManager = new ExportManager(canvas);
                
                // Export functionality
                document.getElementById('export-pdf').addEventListener('click', function() {
                    window.exportManager.exportToPDF();
                });
                
                document.getElementById('export-svg').addEventListener('click', function() {
                    window.exportManager.exportHighQualityPNG();
                });
            }
            
            updateGraphStats(nodeCount, edgeCount, density) {
                const statsElement = document.getElementById('graph-stats');
                const typeStats = window.styleManager ? window.styleManager.getTypeStatistics() : {};
                const nodeTypeCount = typeStats.nodeTypeCount || 0;
                const edgeTypeCount = typeStats.edgeTypeCount || 0;
                
                statsElement.textContent = `${nodeCount} nodes (${nodeTypeCount} types), ${edgeCount} edges (${edgeTypeCount} types)`;
            }
        }

        // Initialize canvas and set up navigation system
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to full window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if (window.canvasNavigator) {
                    window.canvasNavigator.render();
                }
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize style manager
            window.styleManager = new StyleManager();

            // Initialize layout engine
            window.layoutEngine = new GraphLayoutEngine();
            window.labelsEnabled = true;            
            
            window.uiManager = new UIManager();
            // Apply initial layout and discover types if graph data exists
            if (GRAPH_DATA && GRAPH_DATA.nodes && GRAPH_DATA.nodes.length > 0) {
                window.styleManager.discoverTypes(GRAPH_DATA.nodes, GRAPH_DATA.edges);
                // window.layoutEngine.generateInitialLayout(GRAPH_DATA.nodes, GRAPH_DATA.edges);
                window.layoutEngine.generateConcentricLayout(GRAPH_DATA.nodes, GRAPH_DATA.edges);

                // --- Center the graph by shifting node positions ---
                // Compute bounding box of all nodes
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                GRAPH_DATA.nodes.forEach(node => {
                    if (node.x < minX) minX = node.x;
                    if (node.y < minY) minY = node.y;
                    if (node.x > maxX) maxX = node.x;
                    if (node.y > maxY) maxY = node.y;
                });
                const graphWidth = maxX - minX;
                const graphHeight = maxY - minY;

                // Center of graph in world coordinates
                const graphCenterX = minX + graphWidth / 2;
                const graphCenterY = minY + graphHeight / 2;

                // Center of canvas in screen coordinates
                const canvasCenterX = window.innerWidth / 2;
                const canvasCenterY = window.innerHeight / 2;

                // Calculate offset to shift all nodes so the graph is centered
                const offsetX = canvasCenterX - graphCenterX;
                const offsetY = canvasCenterY - graphCenterY;

                // Shift all node positions
                GRAPH_DATA.nodes.forEach(node => {
                    node.x += offsetX;
                    node.y += offsetY;
                });

                // No need to set window.initialTransform for centering
            }
            
            // Initialize navigation system
            window.canvasNavigator = new CanvasNavigator(canvas, ctx);
            
            // Update title and stats
            document.getElementById('graph-title').textContent = GRAPH_DATA.metadata.title;
            
            // Update stats with type information
            if (window.uiManager) {
                window.uiManager.updateGraphStats(
                    GRAPH_DATA.metadata.nodeCount, 
                    GRAPH_DATA.metadata.edgeCount, 
                    GRAPH_DATA.metadata.density
                );
            } else {
                document.getElementById('graph-stats').textContent = 
                    `${GRAPH_DATA.metadata.nodeCount} nodes, ${GRAPH_DATA.metadata.edgeCount} edges`;
            }
            
            // Hide context menu on click outside
            document.addEventListener('click', function() {
                document.getElementById('context-menu').classList.add('hidden');
            });
            
            console.log('Interactive Graph Visualizer with navigation system and UI components loaded successfully');
        });
    </script>
</body>
</html>
